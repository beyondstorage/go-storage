// Code generated by go generate cmd/definitions; DO NOT EDIT.
package types

import (
	"context"
	"io"
	"net/http"
	"time"
)

// Servicer can maintain multipart storage services.
type Servicer interface {
	String() string
	// Create will create a new storager instance.
	Create(name string, pairs ...Pair) (store Storager, err error)
	// CreateWithContext will create a new storager instance.
	CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error)

	// Delete will delete a storager instance.
	Delete(name string, pairs ...Pair) (err error)
	// DeleteWithContext will delete a storager instance.
	DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error)

	// Features will get the suppoted features in Servicer.
	Features() (srvf ServiceFeatures)

	// Get will get a valid storager instance for service.
	Get(name string, pairs ...Pair) (store Storager, err error)
	// GetWithContext will get a valid storager instance for service.
	GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error)

	// List will list all storager instances under this service.
	List(pairs ...Pair) (sti *StoragerIterator, err error)
	// ListWithContext will list all storager instances under this service.
	ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error)

	mustEmbedUnimplementedServicer()
}

// UnimplementedServicer must be embedded to have forward compatible implementations.
//
// Servicer can maintain multipart storage services.
type UnimplementedServicer struct {
}

func (s UnimplementedServicer) mustEmbedUnimplementedServicer() {

}
func (s UnimplementedServicer) String() string {
	return "UnimplementedServicer"
}
func (s UnimplementedServicer) Create(name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("create")
	return
}
func (s UnimplementedServicer) CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("create")
	return
}
func (s UnimplementedServicer) Delete(name string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedServicer) DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedServicer) Features() (srvf ServiceFeatures) {
	return
}
func (s UnimplementedServicer) Get(name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("get")
	return
}
func (s UnimplementedServicer) GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("get")
	return
}
func (s UnimplementedServicer) List(pairs ...Pair) (sti *StoragerIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedServicer) ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}

// Storager is the interface for storage service.
type Storager interface {
	String() string
	// CombineBlock will combine blocks into an object.
	CombineBlock(o *Object, bids []string, pairs ...Pair) (err error)
	// CombineBlockWithContext will combine blocks into an object.
	CombineBlockWithContext(ctx context.Context, o *Object, bids []string, pairs ...Pair) (err error)

	// CommitAppend will commit and finish an append process.
	CommitAppend(o *Object, pairs ...Pair) (err error)
	// CommitAppendWithContext will commit and finish an append process.
	CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error)

	// CompleteMultipart will complete a multipart upload and construct an Object.
	CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error)
	// CompleteMultipartWithContext will complete a multipart upload and construct an Object.
	CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error)

	// Copy will copy an Object or multiple object in the service.
	//
	// ## Behavior
	//
	// - Copy only copy one and only one object.
	//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
	//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
	//   - Copy a file to a directory SHOULD return `ErrObjectModeInvalid`.
	// - Copy SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or
	// not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object
	// if exists.
	// - A successful copy opration should be complete, which means the dst object's content and metadata
	// should be the same as src object.
	Copy(src string, dst string, pairs ...Pair) (err error)
	// CopyWithContext will copy an Object or multiple object in the service.
	//
	// ## Behavior
	//
	// - Copy only copy one and only one object.
	//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
	//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
	//   - Copy a file to a directory SHOULD return `ErrObjectModeInvalid`.
	// - Copy SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or
	// not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object
	// if exists.
	// - A successful copy opration should be complete, which means the dst object's content and metadata
	// should be the same as src object.
	CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error)

	// Create will create a new object without any api call.
	//
	// ## Behavior
	//
	// - Create SHOULD NOT send any API call.
	// - Create SHOULD accept ObjectMode pair as object mode.
	Create(path string, pairs ...Pair) (o *Object)

	// CreateAppend will create an append object.
	//
	// ## Behavior
	//
	// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
	// - CreateAppend SHOULD NOT return an error as the object exist.
	//   - Service SHOULD check and delete the object if exists.
	CreateAppend(path string, pairs ...Pair) (o *Object, err error)
	// CreateAppendWithContext will create an append object.
	//
	// ## Behavior
	//
	// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
	// - CreateAppend SHOULD NOT return an error as the object exist.
	//   - Service SHOULD check and delete the object if exists.
	CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateBlock will create a new block object.
	//
	// ## Behavior
	// - CreateBlock SHOULD NOT return an error as the object exist.
	//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if
	// exists.
	CreateBlock(path string, pairs ...Pair) (o *Object, err error)
	// CreateBlockWithContext will create a new block object.
	//
	// ## Behavior
	// - CreateBlock SHOULD NOT return an error as the object exist.
	//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if
	// exists.
	CreateBlockWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateDir will create a new dir object.
	CreateDir(path string, pairs ...Pair) (o *Object, err error)
	// CreateDirWithContext will create a new dir object.
	CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateLink Will create a link object.
	//
	// # Behavior
	//
	// - `path` and `target` COULD be relative or absolute path.
	// - If `target` not exists, CreateLink will still create a link object to path.
	// - If `path` exists:
	//   - If `path` is a symlink object, CreateLink will remove the symlink object and create a new link object
	// to path.
	//   - If `path` is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when
	// the service does not support overwrite.
	// - A link object COULD be returned in `Stat` or `List`.
	// - CreateLink COULD implement virtual_link feature when service without native support.
	//   - Users SHOULD enable this feature by themselves.
	CreateLink(path string, target string, pairs ...Pair) (o *Object, err error)
	// CreateLinkWithContext Will create a link object.
	//
	// # Behavior
	//
	// - `path` and `target` COULD be relative or absolute path.
	// - If `target` not exists, CreateLink will still create a link object to path.
	// - If `path` exists:
	//   - If `path` is a symlink object, CreateLink will remove the symlink object and create a new link object
	// to path.
	//   - If `path` is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when
	// the service does not support overwrite.
	// - A link object COULD be returned in `Stat` or `List`.
	// - CreateLink COULD implement virtual_link feature when service without native support.
	//   - Users SHOULD enable this feature by themselves.
	CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error)

	// CreateMultipart will create a new multipart.
	//
	// ## Behavior
	//
	// - CreateMultipart SHOULD NOT return an error as the object exists.
	CreateMultipart(path string, pairs ...Pair) (o *Object, err error)
	// CreateMultipartWithContext will create a new multipart.
	//
	// ## Behavior
	//
	// - CreateMultipart SHOULD NOT return an error as the object exists.
	CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreatePage will create a new page object.
	//
	// ## Behavior
	//
	// - CreatePage SHOULD NOT return an error as the object exists.
	CreatePage(path string, pairs ...Pair) (o *Object, err error)
	// CreatePageWithContext will create a new page object.
	//
	// ## Behavior
	//
	// - CreatePage SHOULD NOT return an error as the object exists.
	CreatePageWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// Delete will delete an object from service.
	//
	// ## Behavior
	//
	// - Delete only delete one and only one object.
	//   - Service DON'T NEED to support remove all.
	//   - User NEED to implement remove_all by themself.
	// - Delete is idempotent.
	//   - Successful delete always return nil error.
	//   - Delete SHOULD never return `ObjectNotExist`
	//   - Delete DON'T NEED to check the object exist or not.
	Delete(path string, pairs ...Pair) (err error)
	// DeleteWithContext will delete an object from service.
	//
	// ## Behavior
	//
	// - Delete only delete one and only one object.
	//   - Service DON'T NEED to support remove all.
	//   - User NEED to implement remove_all by themself.
	// - Delete is idempotent.
	//   - Successful delete always return nil error.
	//   - Delete SHOULD never return `ObjectNotExist`
	//   - Delete DON'T NEED to check the object exist or not.
	DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error)

	// Features will get the suppoted features in Storager.
	Features() (stof StorageFeatures)

	// Fetch will fetch from a given url to path.
	//
	// ## Behavior
	//
	// - Fetch SHOULD NOT return an error as the object exists.
	// - A successful fetch operation should be complete, which means the object's content and metadata
	// should be the same as requiring from the url.
	Fetch(path string, url string, pairs ...Pair) (err error)
	// FetchWithContext will fetch from a given url to path.
	//
	// ## Behavior
	//
	// - Fetch SHOULD NOT return an error as the object exists.
	// - A successful fetch operation should be complete, which means the object's content and metadata
	// should be the same as requiring from the url.
	FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error)

	// List will return list a specific path.
	//
	// ## Behavior
	//
	// - Service SHOULD support default `ListMode`.
	// - Service SHOULD implement `ListModeDir` without the check for `VirtualDir`.
	// - Service DON'T NEED to `Stat` while in `List`.
	List(path string, pairs ...Pair) (oi *ObjectIterator, err error)
	// ListWithContext will return list a specific path.
	//
	// ## Behavior
	//
	// - Service SHOULD support default `ListMode`.
	// - Service SHOULD implement `ListModeDir` without the check for `VirtualDir`.
	// - Service DON'T NEED to `Stat` while in `List`.
	ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error)

	// ListBlock will list blocks belong to this object.
	ListBlock(o *Object, pairs ...Pair) (bi *BlockIterator, err error)
	// ListBlockWithContext will list blocks belong to this object.
	ListBlockWithContext(ctx context.Context, o *Object, pairs ...Pair) (bi *BlockIterator, err error)

	// ListMultipart will list parts belong to this multipart.
	ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error)
	// ListMultipartWithContext will list parts belong to this multipart.
	ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error)

	// Metadata will return current storager metadata.
	Metadata(pairs ...Pair) (meta *StorageMeta)

	// Move will move an object in the service.
	//
	// ## Behavior
	//
	// - Move only move one and only one object.
	//   - Service DON'T NEED to support move a non-empty directory.
	//   - User NEED to implement move a non-empty directory by themself.
	//   - Move a file to a directory SHOULD return `ErrObjectModeInvalid`.
	// - Move SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or
	// not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object
	// if exists.
	// - A successful move operation SHOULD be complete, which means the dst object's content and metadata
	// should be the same as src object.
	Move(src string, dst string, pairs ...Pair) (err error)
	// MoveWithContext will move an object in the service.
	//
	// ## Behavior
	//
	// - Move only move one and only one object.
	//   - Service DON'T NEED to support move a non-empty directory.
	//   - User NEED to implement move a non-empty directory by themself.
	//   - Move a file to a directory SHOULD return `ErrObjectModeInvalid`.
	// - Move SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for `overwrite` doesn't NEED to check the dst object exists or
	// not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the dst object
	// if exists.
	// - A successful move operation SHOULD be complete, which means the dst object's content and metadata
	// should be the same as src object.
	MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error)

	// QuerySignHTTPCompleteMultipart will complete a multipart upload and construct an Object by
	// using query parameters to authenticate requests.
	QuerySignHTTPCompleteMultipart(o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPCompleteMultipartWithContext will complete a multipart upload and construct
	// an Object by using query parameters to authenticate requests.
	QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPCreateMultipart will create a new multipart by using query parameters to authenticate
	// requests.
	QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPCreateMultipartWithContext will create a new multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPDelete will delete an object from service by using query parameters to authenticate
	// requests.
	QuerySignHTTPDelete(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPDeleteWithContext will delete an object from service by using query parameters
	// to authenticate requests.
	QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPListMultipart will list parts belong to this multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPListMultipart(o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPListMultipartWithContext will list parts belong to this multipart by using query
	// parameters to authenticate requests.
	QuerySignHTTPListMultipartWithContext(ctx context.Context, o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPRead will read data from the file by using query parameters to authenticate requests.
	QuerySignHTTPRead(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPReadWithContext will read data from the file by using query parameters to authenticate
	// requests.
	QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPWrite will write data into a file by using query parameters to authenticate requests.
	QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPWriteWithContext will write data into a file by using query parameters to authenticate
	// requests.
	QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPWriteMultipart will write content to a multipart by using query parameters to authenticate
	// requests.
	QuerySignHTTPWriteMultipart(o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPWriteMultipartWithContext will write content to a multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// Read will read the file's data.
	Read(path string, w io.Writer, pairs ...Pair) (n int64, err error)
	// ReadWithContext will read the file's data.
	ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error)

	// Stat will stat a path to get info of an object.
	//
	// ## Behavior
	//
	// - Stat SHOULD accept ObjectMode pair as hints.
	//   - Service COULD have different implementations for different object mode.
	//   - Service SHOULD check if returning ObjectMode is match
	Stat(path string, pairs ...Pair) (o *Object, err error)
	// StatWithContext will stat a path to get info of an object.
	//
	// ## Behavior
	//
	// - Stat SHOULD accept ObjectMode pair as hints.
	//   - Service COULD have different implementations for different object mode.
	//   - Service SHOULD check if returning ObjectMode is match
	StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// Write will write data into a file.
	//
	// ## Behavior
	//
	// - Write SHOULD support users pass nil `io.Reader`.
	//   - Service that has native support for pass nil `io.Reader` doesn't NEED to check the `io.Reader`
	// is nil or not.
	//   - Service that doesn't have native support for pass nil `io.Reader` SHOULD check and create an empty
	// `io.Reader` if it is nil.
	// - Write SHOULD NOT return an error as the object exist.
	//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if
	// exists.
	// - A successful write operation SHOULD be complete, which means the object's content and metadata
	// should be the same as specified in write request.
	Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error)
	// WriteWithContext will write data into a file.
	//
	// ## Behavior
	//
	// - Write SHOULD support users pass nil `io.Reader`.
	//   - Service that has native support for pass nil `io.Reader` doesn't NEED to check the `io.Reader`
	// is nil or not.
	//   - Service that doesn't have native support for pass nil `io.Reader` SHOULD check and create an empty
	// `io.Reader` if it is nil.
	// - Write SHOULD NOT return an error as the object exist.
	//   - Service that has native support for `overwrite` doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for `overwrite` SHOULD check and delete the object if
	// exists.
	// - A successful write operation SHOULD be complete, which means the object's content and metadata
	// should be the same as specified in write request.
	WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error)

	// WriteAppend will append content to an append object.
	WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error)
	// WriteAppendWithContext will append content to an append object.
	WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error)

	// WriteBlock will write content to a block.
	WriteBlock(o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error)
	// WriteBlockWithContext will write content to a block.
	WriteBlockWithContext(ctx context.Context, o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error)

	// WriteMultipart will write content to a multipart.
	WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error)
	// WriteMultipartWithContext will write content to a multipart.
	WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error)

	// WritePage will write content to specific offset.
	WritePage(o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error)
	// WritePageWithContext will write content to specific offset.
	WritePageWithContext(ctx context.Context, o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error)

	mustEmbedUnimplementedStorager()
}

// UnimplementedStorager must be embedded to have forward compatible implementations.
//
// Storager is the interface for storage service.
type UnimplementedStorager struct {
}

func (s UnimplementedStorager) mustEmbedUnimplementedStorager() {

}
func (s UnimplementedStorager) String() string {
	return "UnimplementedStorager"
}
func (s UnimplementedStorager) CombineBlock(o *Object, bids []string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("combine_block")
	return
}
func (s UnimplementedStorager) CombineBlockWithContext(ctx context.Context, o *Object, bids []string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("combine_block")
	return
}
func (s UnimplementedStorager) CommitAppend(o *Object, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("commit_append")
	return
}
func (s UnimplementedStorager) CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("commit_append")
	return
}
func (s UnimplementedStorager) CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("complete_multipart")
	return
}
func (s UnimplementedStorager) CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("complete_multipart")
	return
}
func (s UnimplementedStorager) Copy(src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("copy")
	return
}
func (s UnimplementedStorager) CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("copy")
	return
}
func (s UnimplementedStorager) Create(path string, pairs ...Pair) (o *Object) {
	return
}
func (s UnimplementedStorager) CreateAppend(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_append")
	return
}
func (s UnimplementedStorager) CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_append")
	return
}
func (s UnimplementedStorager) CreateBlock(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_block")
	return
}
func (s UnimplementedStorager) CreateBlockWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_block")
	return
}
func (s UnimplementedStorager) CreateDir(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_dir")
	return
}
func (s UnimplementedStorager) CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_dir")
	return
}
func (s UnimplementedStorager) CreateLink(path string, target string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_link")
	return
}
func (s UnimplementedStorager) CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_link")
	return
}
func (s UnimplementedStorager) CreateMultipart(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_multipart")
	return
}
func (s UnimplementedStorager) CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_multipart")
	return
}
func (s UnimplementedStorager) CreatePage(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_page")
	return
}
func (s UnimplementedStorager) CreatePageWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_page")
	return
}
func (s UnimplementedStorager) Delete(path string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedStorager) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedStorager) Features() (stof StorageFeatures) {
	return
}
func (s UnimplementedStorager) Fetch(path string, url string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("fetch")
	return
}
func (s UnimplementedStorager) FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("fetch")
	return
}
func (s UnimplementedStorager) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedStorager) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedStorager) ListBlock(o *Object, pairs ...Pair) (bi *BlockIterator, err error) {
	err = NewOperationNotImplementedError("list_block")
	return
}
func (s UnimplementedStorager) ListBlockWithContext(ctx context.Context, o *Object, pairs ...Pair) (bi *BlockIterator, err error) {
	err = NewOperationNotImplementedError("list_block")
	return
}
func (s UnimplementedStorager) ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	err = NewOperationNotImplementedError("list_multipart")
	return
}
func (s UnimplementedStorager) ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	err = NewOperationNotImplementedError("list_multipart")
	return
}
func (s UnimplementedStorager) Metadata(pairs ...Pair) (meta *StorageMeta) {
	return
}
func (s UnimplementedStorager) Move(src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("move")
	return
}
func (s UnimplementedStorager) MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("move")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCompleteMultipart(o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_complete_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_complete_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_create_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_create_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPDelete(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_delete")
	return
}
func (s UnimplementedStorager) QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_delete")
	return
}
func (s UnimplementedStorager) QuerySignHTTPListMultipart(o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_list_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPListMultipartWithContext(ctx context.Context, o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_list_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPRead(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_read")
	return
}
func (s UnimplementedStorager) QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_read")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteMultipart(o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write_multipart")
	return
}
func (s UnimplementedStorager) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("read")
	return
}
func (s UnimplementedStorager) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("read")
	return
}
func (s UnimplementedStorager) Stat(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("stat")
	return
}
func (s UnimplementedStorager) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("stat")
	return
}
func (s UnimplementedStorager) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write")
	return
}
func (s UnimplementedStorager) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write")
	return
}
func (s UnimplementedStorager) WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_append")
	return
}
func (s UnimplementedStorager) WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_append")
	return
}
func (s UnimplementedStorager) WriteBlock(o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_block")
	return
}
func (s UnimplementedStorager) WriteBlockWithContext(ctx context.Context, o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_block")
	return
}
func (s UnimplementedStorager) WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	err = NewOperationNotImplementedError("write_multipart")
	return
}
func (s UnimplementedStorager) WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	err = NewOperationNotImplementedError("write_multipart")
	return
}
func (s UnimplementedStorager) WritePage(o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_page")
	return
}
func (s UnimplementedStorager) WritePageWithContext(ctx context.Context, o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_page")
	return
}
