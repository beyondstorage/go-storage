// Code generated by go generate cmd/definitions; DO NOT EDIT.
package types

import (
	"context"
	"io"
	"net/http"
	"time"
)

type Servicer interface {
	String() string
	Features() ServiceFeatures
	// Create will create a new storager instance.
	Create(name string, pairs ...Pair) (store Storager, err error)
	// CreateWithContext will create a new storager instance.
	CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error)

	// Delete will delete a storager instance.
	Delete(name string, pairs ...Pair) (err error)
	// DeleteWithContext will delete a storager instance.
	DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error)

	// Get will get a valid storager instance for service.
	Get(name string, pairs ...Pair) (store Storager, err error)
	// GetWithContext will get a valid storager instance for service.
	GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error)

	// List will list all storager instances under this service.
	List(pairs ...Pair) (sti *StoragerIterator, err error)
	// ListWithContext will list all storager instances under this service.
	ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error)

	mustEmbedUnimplementedServicer()
}

// UnimplementedServicer must be embedded to have forward compatible implementations.
type UnimplementedServicer struct {
}

func (s UnimplementedServicer) mustEmbedUnimplementedServicer() {

}
func (s UnimplementedServicer) String() string {
	return "UnimplementedServicer"
}
func (s UnimplementedServicer) Features() (fe ServiceFeatures) {
	return
}
func (s UnimplementedServicer) Create(name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("create")
	return
}
func (s UnimplementedServicer) CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("create")
	return
}
func (s UnimplementedServicer) Delete(name string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedServicer) DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedServicer) Get(name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("get")
	return
}
func (s UnimplementedServicer) GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	err = NewOperationNotImplementedError("get")
	return
}
func (s UnimplementedServicer) List(pairs ...Pair) (sti *StoragerIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedServicer) ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}

// DefaultServicePairs is the default pairs for Service.
type DefaultServicePairs struct {
	Create []Pair
	Delete []Pair
	Get    []Pair
	List   []Pair
}

// ServiceFeatures indicates features supported by servicer.
type ServiceFeatures struct {
	LoosePair bool
	Create    bool
	Delete    bool
	Get       bool
	List      bool
}

func (s ServiceFeatures) Has(name string) bool {
	switch name {
	case "loose_pair":
		return s.LoosePair
	case "create":
		return s.Create
	case "delete":
		return s.Delete
	case "get":
		return s.Get
	case "list":
		return s.List
	default:
		return false
	}
}

type Storager interface {
	String() string
	Features() StorageFeatures
	// CombineBlock will combine blocks into an object.
	CombineBlock(o *Object, bids []string, pairs ...Pair) (err error)
	// CombineBlockWithContext will combine blocks into an object.
	CombineBlockWithContext(ctx context.Context, o *Object, bids []string, pairs ...Pair) (err error)

	// CommitAppend will commit and finish an append process.
	CommitAppend(o *Object, pairs ...Pair) (err error)
	// CommitAppendWithContext will commit and finish an append process.
	CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error)

	// CompleteMultipart will complete a multipart upload and construct an Object.
	CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error)
	// CompleteMultipartWithContext will complete a multipart upload and construct an Object.
	CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error)

	// Copy will copy an Object or multiple object in the service.
	//
	// ## Behavior
	//
	// - Copy only copy one and only one object.
	//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
	//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
	//   - Copy a file to a directory SHOULD return ErrObjectModeInvalid.
	// - Copy SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for overwrite doesn't NEED to check the dst object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the dst object
	// if exists.
	// - A successful copy opration should be complete, which means the dst object's content and metadata
	// should be the same as src object.
	Copy(src string, dst string, pairs ...Pair) (err error)
	// CopyWithContext will copy an Object or multiple object in the service.
	//
	// ## Behavior
	//
	// - Copy only copy one and only one object.
	//   - Service DON'T NEED to support copy a non-empty directory or copy files recursively.
	//   - User NEED to implement copy a non-empty directory and copy recursively by themself.
	//   - Copy a file to a directory SHOULD return ErrObjectModeInvalid.
	// - Copy SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for overwrite doesn't NEED to check the dst object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the dst object
	// if exists.
	// - A successful copy opration should be complete, which means the dst object's content and metadata
	// should be the same as src object.
	CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error)

	// Create will create a new object without any api call.
	//
	// ## Behavior
	//
	// - Create SHOULD NOT send any API call.
	// - Create SHOULD accept ObjectMode pair as object mode.
	Create(path string, pairs ...Pair) (o *Object)

	// CreateAppend will create an append object.
	//
	// ## Behavior
	//
	// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
	// - CreateAppend SHOULD NOT return an error as the object exist.
	//   - Service SHOULD check and delete the object if exists.
	CreateAppend(path string, pairs ...Pair) (o *Object, err error)
	// CreateAppendWithContext will create an append object.
	//
	// ## Behavior
	//
	// - CreateAppend SHOULD create an appendable object with position 0 and size 0.
	// - CreateAppend SHOULD NOT return an error as the object exist.
	//   - Service SHOULD check and delete the object if exists.
	CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateBlock will create a new block object.
	//
	// ## Behavior
	// - CreateBlock SHOULD NOT return an error as the object exist.
	//   - Service that has native support for overwrite doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the object if exists.
	CreateBlock(path string, pairs ...Pair) (o *Object, err error)
	// CreateBlockWithContext will create a new block object.
	//
	// ## Behavior
	// - CreateBlock SHOULD NOT return an error as the object exist.
	//   - Service that has native support for overwrite doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the object if exists.
	CreateBlockWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateDir will create a new dir object
	CreateDir(path string, pairs ...Pair) (o *Object, err error)
	// CreateDirWithContext will create a new dir object
	CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreateLink Will create a link object.
	//
	// # Behavior
	//
	// - path and target COULD be relative or absolute path.
	// - If target not exists, CreateLink will still create a link object to path.
	// - If path exists:
	//   - If path is a symlink object, CreateLink will remove the symlink object and create a new link object
	// to path.
	//   - If path is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when the
	// service does not support overwrite.
	// - A link object COULD be returned in Stat or List.
	// - CreateLink COULD implement virtual_link feature when service without native support.
	//   - Users SHOULD enable this feature by themselves.
	CreateLink(path string, target string, pairs ...Pair) (o *Object, err error)
	// CreateLinkWithContext Will create a link object.
	//
	// # Behavior
	//
	// - path and target COULD be relative or absolute path.
	// - If target not exists, CreateLink will still create a link object to path.
	// - If path exists:
	//   - If path is a symlink object, CreateLink will remove the symlink object and create a new link object
	// to path.
	//   - If path is not a symlink object, CreateLink will return an ErrObjectModeInvalid error when the
	// service does not support overwrite.
	// - A link object COULD be returned in Stat or List.
	// - CreateLink COULD implement virtual_link feature when service without native support.
	//   - Users SHOULD enable this feature by themselves.
	CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error)

	// CreateMultipart will create a new multipart.
	//
	// ## Behavior
	//
	// - CreateMultipart SHOULD NOT return an error as the object exists.
	CreateMultipart(path string, pairs ...Pair) (o *Object, err error)
	// CreateMultipartWithContext will create a new multipart.
	//
	// ## Behavior
	//
	// - CreateMultipart SHOULD NOT return an error as the object exists.
	CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// CreatePage will create a new page object.
	//
	// ## Behavior
	//
	// - CreatePage SHOULD NOT return an error as the object exists.
	CreatePage(path string, pairs ...Pair) (o *Object, err error)
	// CreatePageWithContext will create a new page object.
	//
	// ## Behavior
	//
	// - CreatePage SHOULD NOT return an error as the object exists.
	CreatePageWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// Delete will delete an object from service.
	//
	// ## Behavior
	//
	// - Delete only delete one and only one object.
	//   - Service DON'T NEED to support remove all.
	//   - User NEED to implement remove_all by themself.
	// - Delete is idempotent.
	//   - Successful delete always return nil error.
	//   - Delete SHOULD never return ObjectNotExist
	//   - Delete DON'T NEED to check the object exist or not.
	Delete(path string, pairs ...Pair) (err error)
	// DeleteWithContext will delete an object from service.
	//
	// ## Behavior
	//
	// - Delete only delete one and only one object.
	//   - Service DON'T NEED to support remove all.
	//   - User NEED to implement remove_all by themself.
	// - Delete is idempotent.
	//   - Successful delete always return nil error.
	//   - Delete SHOULD never return ObjectNotExist
	//   - Delete DON'T NEED to check the object exist or not.
	DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error)

	// Fetch will fetch from a given url to path.
	//
	// ## Behavior
	//
	// - Fetch SHOULD NOT return an error as the object exists.
	// - A successful fetch operation should be complete, which means the object's content and metadata
	// should be the same as requiring from the url.
	Fetch(path string, url string, pairs ...Pair) (err error)
	// FetchWithContext will fetch from a given url to path.
	//
	// ## Behavior
	//
	// - Fetch SHOULD NOT return an error as the object exists.
	// - A successful fetch operation should be complete, which means the object's content and metadata
	// should be the same as requiring from the url.
	FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error)

	// List will return list a specific path.
	//
	// ## Behavior
	//
	// - Service SHOULD support default ListMode.
	// - Service SHOULD implement ListModeDir without the check for VirtualDir.
	// - Service DON'T NEED to Stat while in List.
	List(path string, pairs ...Pair) (oi *ObjectIterator, err error)
	// ListWithContext will return list a specific path.
	//
	// ## Behavior
	//
	// - Service SHOULD support default ListMode.
	// - Service SHOULD implement ListModeDir without the check for VirtualDir.
	// - Service DON'T NEED to Stat while in List.
	ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error)

	// ListBlock will list blocks belong to this object.
	ListBlock(o *Object, pairs ...Pair) (bi *BlockIterator, err error)
	// ListBlockWithContext will list blocks belong to this object.
	ListBlockWithContext(ctx context.Context, o *Object, pairs ...Pair) (bi *BlockIterator, err error)

	// ListMultipart will list parts belong to this multipart.
	ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error)
	// ListMultipartWithContext will list parts belong to this multipart.
	ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error)

	// Metadata will return current storager metadata.
	Metadata(pairs ...Pair) (meta *StorageMeta)

	// Move will move an object in the service.
	//
	// ## Behavior
	//
	// - Move only move one and only one object.
	//   - Service DON'T NEED to support move a non-empty directory.
	//   - User NEED to implement move a non-empty directory by themself.
	//   - Move a file to a directory SHOULD return ErrObjectModeInvalid.
	// - Move SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for overwrite doesn't NEED to check the dst object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the dst object
	// if exists.
	// - A successful move operation SHOULD be complete, which means the dst object's content and metadata
	// should be the same as src object.
	Move(src string, dst string, pairs ...Pair) (err error)
	// MoveWithContext will move an object in the service.
	//
	// ## Behavior
	//
	// - Move only move one and only one object.
	//   - Service DON'T NEED to support move a non-empty directory.
	//   - User NEED to implement move a non-empty directory by themself.
	//   - Move a file to a directory SHOULD return ErrObjectModeInvalid.
	// - Move SHOULD NOT return an error as dst object exists.
	//   - Service that has native support for overwrite doesn't NEED to check the dst object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the dst object
	// if exists.
	// - A successful move operation SHOULD be complete, which means the dst object's content and metadata
	// should be the same as src object.
	MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error)

	// QuerySignHTTPCompleteMultipart will complete a multipart upload and construct an Object by
	// using query parameters to authenticate requests.
	QuerySignHTTPCompleteMultipart(o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPCompleteMultipartWithContext will complete a multipart upload and construct
	// an Object by using query parameters to authenticate requests.
	QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPCreateMultipart will create a new multipart by using query parameters to authenticate
	// requests.
	QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPCreateMultipartWithContext will create a new multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPDelete will delete an object from service by using query parameters to authenticate
	// requests.
	QuerySignHTTPDelete(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPDeleteWithContext will delete an object from service by using query parameters
	// to authenticate requests.
	QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPListMultipart will list parts belong to this multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPListMultipart(o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPListMultipartWithContext will list parts belong to this multipart by using query
	// parameters to authenticate requests.
	QuerySignHTTPListMultipartWithContext(ctx context.Context, o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPRead will read data from the file by using query parameters to authenticate requests.
	QuerySignHTTPRead(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPReadWithContext will read data from the file by using query parameters to authenticate
	// requests.
	QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPWrite will write data into a file by using query parameters to authenticate requests.
	QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPWriteWithContext will write data into a file by using query parameters to authenticate
	// requests.
	QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// QuerySignHTTPWriteMultipart will write content to a multipart by using query parameters to authenticate
	// requests.
	QuerySignHTTPWriteMultipart(o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error)
	// QuerySignHTTPWriteMultipartWithContext will write content to a multipart by using query parameters
	// to authenticate requests.
	QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error)

	// Read will read the file's data.
	Read(path string, w io.Writer, pairs ...Pair) (n int64, err error)
	// ReadWithContext will read the file's data.
	ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error)

	// Stat will stat a path to get info of an object.
	//
	// ## Behavior
	//
	// - Stat SHOULD accept ObjectMode pair as hints.
	//   - Service COULD have different implementations for different object mode.
	//   - Service SHOULD check if returning ObjectMode is match
	Stat(path string, pairs ...Pair) (o *Object, err error)
	// StatWithContext will stat a path to get info of an object.
	//
	// ## Behavior
	//
	// - Stat SHOULD accept ObjectMode pair as hints.
	//   - Service COULD have different implementations for different object mode.
	//   - Service SHOULD check if returning ObjectMode is match
	StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error)

	// Write will write data into a file.
	//
	// ## Behavior
	//
	// - Write SHOULD support users pass nil io.Reader.
	//   - Service that has native support for pass nil io.Reader doesn't NEED to check the io.Reader is nil
	// or not.
	//   - Service that doesn't have native support for pass nil io.Reader SHOULD check and create an empty
	// io.Reader if it is nil.
	// - Write SHOULD NOT return an error as the object exist.
	//   - Service that has native support for overwrite doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the object if exists.
	// - A successful write operation SHOULD be complete, which means the object's content and metadata
	// should be the same as specified in write request.
	Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error)
	// WriteWithContext will write data into a file.
	//
	// ## Behavior
	//
	// - Write SHOULD support users pass nil io.Reader.
	//   - Service that has native support for pass nil io.Reader doesn't NEED to check the io.Reader is nil
	// or not.
	//   - Service that doesn't have native support for pass nil io.Reader SHOULD check and create an empty
	// io.Reader if it is nil.
	// - Write SHOULD NOT return an error as the object exist.
	//   - Service that has native support for overwrite doesn't NEED to check the object exists or not.
	//   - Service that doesn't have native support for overwrite SHOULD check and delete the object if exists.
	// - A successful write operation SHOULD be complete, which means the object's content and metadata
	// should be the same as specified in write request.
	WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error)

	// WriteAppend will append content to an append object.
	WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error)
	// WriteAppendWithContext will append content to an append object.
	WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error)

	// WriteBlock will write content to a block.
	WriteBlock(o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error)
	// WriteBlockWithContext will write content to a block.
	WriteBlockWithContext(ctx context.Context, o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error)

	// WriteMultipart will write content to a multipart.
	WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error)
	// WriteMultipartWithContext will write content to a multipart.
	WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error)

	// WritePage will write content to specific offset.
	WritePage(o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error)
	// WritePageWithContext will write content to specific offset.
	WritePageWithContext(ctx context.Context, o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error)

	mustEmbedUnimplementedStorager()
}

// UnimplementedStorager must be embedded to have forward compatible implementations.
type UnimplementedStorager struct {
}

func (s UnimplementedStorager) mustEmbedUnimplementedStorager() {

}
func (s UnimplementedStorager) String() string {
	return "UnimplementedStorager"
}
func (s UnimplementedStorager) Features() (fe StorageFeatures) {
	return
}
func (s UnimplementedStorager) CombineBlock(o *Object, bids []string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("combine_block")
	return
}
func (s UnimplementedStorager) CombineBlockWithContext(ctx context.Context, o *Object, bids []string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("combine_block")
	return
}
func (s UnimplementedStorager) CommitAppend(o *Object, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("commit_append")
	return
}
func (s UnimplementedStorager) CommitAppendWithContext(ctx context.Context, o *Object, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("commit_append")
	return
}
func (s UnimplementedStorager) CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("complete_multipart")
	return
}
func (s UnimplementedStorager) CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("complete_multipart")
	return
}
func (s UnimplementedStorager) Copy(src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("copy")
	return
}
func (s UnimplementedStorager) CopyWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("copy")
	return
}
func (s UnimplementedStorager) Create(path string, pairs ...Pair) (o *Object) {
	return
}
func (s UnimplementedStorager) CreateAppend(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_append")
	return
}
func (s UnimplementedStorager) CreateAppendWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_append")
	return
}
func (s UnimplementedStorager) CreateBlock(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_block")
	return
}
func (s UnimplementedStorager) CreateBlockWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_block")
	return
}
func (s UnimplementedStorager) CreateDir(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_dir")
	return
}
func (s UnimplementedStorager) CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_dir")
	return
}
func (s UnimplementedStorager) CreateLink(path string, target string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_link")
	return
}
func (s UnimplementedStorager) CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_link")
	return
}
func (s UnimplementedStorager) CreateMultipart(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_multipart")
	return
}
func (s UnimplementedStorager) CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_multipart")
	return
}
func (s UnimplementedStorager) CreatePage(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_page")
	return
}
func (s UnimplementedStorager) CreatePageWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("create_page")
	return
}
func (s UnimplementedStorager) Delete(path string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedStorager) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("delete")
	return
}
func (s UnimplementedStorager) Fetch(path string, url string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("fetch")
	return
}
func (s UnimplementedStorager) FetchWithContext(ctx context.Context, path string, url string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("fetch")
	return
}
func (s UnimplementedStorager) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedStorager) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	err = NewOperationNotImplementedError("list")
	return
}
func (s UnimplementedStorager) ListBlock(o *Object, pairs ...Pair) (bi *BlockIterator, err error) {
	err = NewOperationNotImplementedError("list_block")
	return
}
func (s UnimplementedStorager) ListBlockWithContext(ctx context.Context, o *Object, pairs ...Pair) (bi *BlockIterator, err error) {
	err = NewOperationNotImplementedError("list_block")
	return
}
func (s UnimplementedStorager) ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	err = NewOperationNotImplementedError("list_multipart")
	return
}
func (s UnimplementedStorager) ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	err = NewOperationNotImplementedError("list_multipart")
	return
}
func (s UnimplementedStorager) Metadata(pairs ...Pair) (meta *StorageMeta) {
	return
}
func (s UnimplementedStorager) Move(src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("move")
	return
}
func (s UnimplementedStorager) MoveWithContext(ctx context.Context, src string, dst string, pairs ...Pair) (err error) {
	err = NewOperationNotImplementedError("move")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCompleteMultipart(o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_complete_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_complete_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_create_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_create_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPDelete(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_delete")
	return
}
func (s UnimplementedStorager) QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_delete")
	return
}
func (s UnimplementedStorager) QuerySignHTTPListMultipart(o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_list_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPListMultipartWithContext(ctx context.Context, o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_list_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPRead(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_read")
	return
}
func (s UnimplementedStorager) QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_read")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteMultipart(o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write_multipart")
	return
}
func (s UnimplementedStorager) QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	err = NewOperationNotImplementedError("query_sign_http_write_multipart")
	return
}
func (s UnimplementedStorager) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("read")
	return
}
func (s UnimplementedStorager) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("read")
	return
}
func (s UnimplementedStorager) Stat(path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("stat")
	return
}
func (s UnimplementedStorager) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	err = NewOperationNotImplementedError("stat")
	return
}
func (s UnimplementedStorager) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write")
	return
}
func (s UnimplementedStorager) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write")
	return
}
func (s UnimplementedStorager) WriteAppend(o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_append")
	return
}
func (s UnimplementedStorager) WriteAppendWithContext(ctx context.Context, o *Object, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_append")
	return
}
func (s UnimplementedStorager) WriteBlock(o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_block")
	return
}
func (s UnimplementedStorager) WriteBlockWithContext(ctx context.Context, o *Object, r io.Reader, size int64, bid string, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_block")
	return
}
func (s UnimplementedStorager) WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	err = NewOperationNotImplementedError("write_multipart")
	return
}
func (s UnimplementedStorager) WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	err = NewOperationNotImplementedError("write_multipart")
	return
}
func (s UnimplementedStorager) WritePage(o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_page")
	return
}
func (s UnimplementedStorager) WritePageWithContext(ctx context.Context, o *Object, r io.Reader, size int64, offset int64, pairs ...Pair) (n int64, err error) {
	err = NewOperationNotImplementedError("write_page")
	return
}

// DefaultStoragePairs is the default pairs for Storage.
type DefaultStoragePairs struct {
	CombineBlock                   []Pair
	CommitAppend                   []Pair
	CompleteMultipart              []Pair
	Copy                           []Pair
	Create                         []Pair
	CreateAppend                   []Pair
	CreateBlock                    []Pair
	CreateDir                      []Pair
	CreateLink                     []Pair
	CreateMultipart                []Pair
	CreatePage                     []Pair
	Delete                         []Pair
	Fetch                          []Pair
	List                           []Pair
	ListBlock                      []Pair
	ListMultipart                  []Pair
	Metadata                       []Pair
	Move                           []Pair
	QuerySignHTTPCompleteMultipart []Pair
	QuerySignHTTPCreateMultipart   []Pair
	QuerySignHTTPDelete            []Pair
	QuerySignHTTPListMultipart     []Pair
	QuerySignHTTPRead              []Pair
	QuerySignHTTPWrite             []Pair
	QuerySignHTTPWriteMultipart    []Pair
	Read                           []Pair
	Stat                           []Pair
	Write                          []Pair
	WriteAppend                    []Pair
	WriteBlock                     []Pair
	WriteMultipart                 []Pair
	WritePage                      []Pair
}

// StorageFeatures indicates features supported by servicer.
type StorageFeatures struct {
	LoosePair                      bool
	VirtualDir                     bool
	VirtualLink                    bool
	VirtualObjectMetadata          bool
	WriteEmptyObject               bool
	Create                         bool
	Delete                         bool
	Metadata                       bool
	List                           bool
	Read                           bool
	Stat                           bool
	Write                          bool
	CreateAppend                   bool
	WriteAppend                    bool
	CommitAppend                   bool
	CreateBlock                    bool
	WriteBlock                     bool
	CombineBlock                   bool
	ListBlock                      bool
	Copy                           bool
	CreateDir                      bool
	Fetch                          bool
	CreateLink                     bool
	Move                           bool
	CreateMultipart                bool
	WriteMultipart                 bool
	CompleteMultipart              bool
	ListMultipart                  bool
	CreatePage                     bool
	WritePage                      bool
	QuerySignHTTPRead              bool
	QuerySignHTTPWrite             bool
	QuerySignHTTPDelete            bool
	QuerySignHTTPCreateMultipart   bool
	QuerySignHTTPWriteMultipart    bool
	QuerySignHTTPListMultipart     bool
	QuerySignHTTPCompleteMultipart bool
}

func (s StorageFeatures) Has(name string) bool {
	switch name {
	case "loose_pair":
		return s.LoosePair
	case "virtual_dir":
		return s.VirtualDir
	case "virtual_link":
		return s.VirtualLink
	case "virtual_object_metadata":
		return s.VirtualObjectMetadata
	case "write_empty_object":
		return s.WriteEmptyObject
	case "create":
		return s.Create
	case "delete":
		return s.Delete
	case "metadata":
		return s.Metadata
	case "list":
		return s.List
	case "read":
		return s.Read
	case "stat":
		return s.Stat
	case "write":
		return s.Write
	case "create_append":
		return s.CreateAppend
	case "write_append":
		return s.WriteAppend
	case "commit_append":
		return s.CommitAppend
	case "create_block":
		return s.CreateBlock
	case "write_block":
		return s.WriteBlock
	case "combine_block":
		return s.CombineBlock
	case "list_block":
		return s.ListBlock
	case "copy":
		return s.Copy
	case "create_dir":
		return s.CreateDir
	case "fetch":
		return s.Fetch
	case "create_link":
		return s.CreateLink
	case "move":
		return s.Move
	case "create_multipart":
		return s.CreateMultipart
	case "write_multipart":
		return s.WriteMultipart
	case "complete_multipart":
		return s.CompleteMultipart
	case "list_multipart":
		return s.ListMultipart
	case "create_page":
		return s.CreatePage
	case "write_page":
		return s.WritePage
	case "query_sign_http_read":
		return s.QuerySignHTTPRead
	case "query_sign_http_write":
		return s.QuerySignHTTPWrite
	case "query_sign_http_delete":
		return s.QuerySignHTTPDelete
	case "query_sign_http_create_multipart":
		return s.QuerySignHTTPCreateMultipart
	case "query_sign_http_write_multipart":
		return s.QuerySignHTTPWriteMultipart
	case "query_sign_http_list_multipart":
		return s.QuerySignHTTPListMultipart
	case "query_sign_http_complete_multipart":
		return s.QuerySignHTTPCompleteMultipart
	default:
		return false
	}
}
