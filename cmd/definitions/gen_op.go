//go:build tools
// +build tools

package main

import (
	"github.com/Xuanwo/gg"
	"github.com/Xuanwo/templateutils"
	log "github.com/sirupsen/logrus"
)

func generateOperation(data *Data, path string) {
	f := gg.Group()
	f.LineComment("Code generated by go generate cmd/definitions; DO NOT EDIT.")
	f.Package("types")
	f.Imports().
		Path("context").
		Path("io").
		Path("net/http").
		Path("time")

	for _, in := range data.Interfaces {
		f.LineComment("%s %s", in.DisplayName(), in.originalDescription)

		inter := f.Interface(in.DisplayName())
		if in.Name == "servicer" || in.Name == "storager" {
			inter.Function("String").Result("", "string")
		}

		for _, op := range in.SortedOps() {
			pname := templateutils.ToPascal(op.Name)

			gop := inter.Function(pname).
				NamedLineComment(op.originalDescription)

			for _, p := range op.Params {
				gop.Parameter(p.Name, p.Type())
			}
			for _, r := range op.Results {
				gop.Result(r.Name, r.Type())
			}

			// We need to generate XxxWithContext functions if not local.
			if !op.Local {
				gop := inter.Function(pname + "WithContext").
					NamedLineComment(op.originalDescription)
				// Insert context param.
				gop.Parameter("ctx", "context.Context")
				for _, p := range op.Params {
					gop.Parameter(p.Name, p.Type())
				}
				for _, r := range op.Results {
					gop.Result(r.Name, r.Type())
				}
			}
			// Insert an empty for different functions.
			inter.Line()
		}
		inter.Function("mustEmbedUnimplemented" + in.DisplayName())

		stubName := "Unimplemented" + in.DisplayName()
		f.LineComment("%s must be embedded to have forward compatible implementations.", stubName)
		f.Struct(stubName)

		f.Function("mustEmbedUnimplemented"+in.DisplayName()).
			Receiver("s", stubName)
		f.Function("String").
			Receiver("s", stubName).
			Result("", "string").
			Body(
				gg.Return().Lit(stubName))

		for _, op := range in.SortedOps() {
			pname := templateutils.ToPascal(op.Name)

			gop := f.Function(pname).
				Receiver("s", stubName)

			for _, p := range op.Params {
				gop.Parameter(p.Name, p.Type())
			}
			for _, r := range op.Results {
				gop.Result(r.Name, r.Type())
			}
			// If not local, we need to set error
			if !op.Local {
				gop.Body(gg.String(`err = NewOperationNotImplementedError("%s")`, op.Name))
			}
			gop.Body(gg.Return())

			// We need to generate XxxWithContext functions if not local.
			if !op.Local {
				gop := f.Function(pname+"WithContext").
					Receiver("s", stubName)

				// Insert context param.
				gop.Parameter("ctx", "context.Context")
				for _, p := range op.Params {
					gop.Parameter(p.Name, p.Type())
				}
				for _, r := range op.Results {
					gop.Result(r.Name, r.Type())
				}
				gop.Body(
					gg.String(`err = NewOperationNotImplementedError("%s")`, op.Name),
					gg.Return(),
				)
			}
		}
	}

	err := f.WriteFile(path)
	if err != nil {
		log.Fatalf("generate to %s: %v", path, err)
	}
}
