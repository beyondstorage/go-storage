//go:build tools
// +build tools

package main

import (
	"fmt"
	"go/parser"
	"go/token"
	"os"
	"sort"
	"text/template"

	"github.com/Xuanwo/templateutils"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/jennifer/jen"
	log "github.com/sirupsen/logrus"

	"github.com/beyondstorage/go-storage/v4/cmd/definitions/bindata"
)

var (
	infoT      = newTmpl("cmd/definitions/tmpl/info")
	serviceT   = newTmpl("cmd/definitions/tmpl/service")
	operationT = newTmpl("cmd/definitions/tmpl/operation")
	functionT  = newTmpl("cmd/definitions/tmpl/function")
	objectT    = newTmpl("cmd/definitions/tmpl/object")
)

func generateGlobal(data *Data) {
	// Metas generate
	generateT(infoT, "types/info.generated.go", data)

	// Pair generate
	generateF("pairs/generated.go", generatePair(data))

	// Operation generate
	generateT(operationT, "types/operation.generated.go", data)

	// Object generate
	generateT(objectT, "types/object.generated.go", data)
}

func generatePair(data *Data) *jen.File {
	f := jen.NewFile("pairs")
	f.HeaderComment("Code generated by go generate cmd/definitions; DO NOT EDIT.")

	// It's a workaround for jen.
	// Technically, we need to use `jen.Qual` to allow jen import correct path for us.
	// But it's not suitable for us. So we hand-write the logic here.
	f.Op("import").Defs(
		jen.Lit("context"),
		jen.Lit("time"),
		jen.Line(),
		jen.Lit("github.com/beyondstorage/go-storage/v4/pkg/httpclient"),
		jen.Op(".").Lit("github.com/beyondstorage/go-storage/v4/types"),
	)

	ps := make([]*Pair, 0, len(data.Pairs))
	for _, v := range data.Pairs {
		v := v
		ps = append(ps, v)
	}
	sort.SliceStable(ps, func(i, j int) bool {
		return ps[i].Name < ps[j].Name
	})

	for _, v := range ps {
		pname := templateutils.ToPascal(v.Name)

		f.Commentf(`With%s will apply %s value to Options.

%s %s`, pname, v.Name, pname, v.originalDescription)

		fn := f.Func().Id("With" + pname)

		// Generate parameter
		fn.Params(jen.Id("v").Id(v.Type()))
		// Generate result
		fn.Params(jen.Id("p").Id("Pair"))

		fn.Block(
			jen.Return(jen.Id("Pair").Values(
				jen.Id("Key").Op(":").Lit(v.Name),
				jen.Id("Value").Op(":").Id("v"),
			)),
		)
	}

	return f
}

func generateF(filePath string, content *jen.File) {
	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf("create file %s: %s", filePath, err)
	}

	err = content.Render(file)
	if err != nil {
		log.Fatalf("write file %s: %s", filePath, err)
	}
}

func generateService(data *Data) {
	generateT(serviceT, "generated.go", data.Service)
	for _, v := range data.Service.Namespaces {
		appendT(functionT, v.Name+".go", v)
		formatService(v.Name + ".go")
	}
}

func generateT(tmpl *template.Template, filePath string, data interface{}) {
	errorMsg := fmt.Sprintf("generate template %s to %s", tmpl.Name(), filePath) + ": %v"

	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
	err = tmpl.Execute(file, data)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
}

func appendT(tmpl *template.Template, filePath string, data interface{}) {
	errorMsg := fmt.Sprintf("append template %s to %s", tmpl.Name(), filePath) + ": %v"

	file, err := os.OpenFile(filePath, os.O_APPEND|os.O_RDWR, 0644)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
	err = tmpl.Execute(file, data)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
}

func newTmpl(name string) *template.Template {
	return template.Must(
		template.New(name).
			Funcs(templateutils.FuncMap()).
			Parse(string(bindata.MustAsset(name + ".tmpl"))))
}

func formatService(filename string) {
	fset := token.NewFileSet()

	f, err := decorator.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("parse file: %v", err)
	}

	// Sort all methods via name.
	// Only allow functions in service.go and storage.go
	sort.SliceStable(f.Decls, func(i, j int) bool {
		fi, ok := f.Decls[i].(*dst.FuncDecl)
		if !ok {
			return false
		}
		fj, ok := f.Decls[j].(*dst.FuncDecl)
		if !ok {
			return false
		}
		return fi.Name.Name < fj.Name.Name
	})

	// Add empty line for every methods.
	dst.Inspect(f, func(node dst.Node) bool {
		if node == nil {
			return false
		}
		fn, ok := node.(*dst.FuncDecl)
		if !ok {
			return true
		}
		fn.Decorations().Before = dst.EmptyLine
		fn.Decorations().After = dst.EmptyLine
		return true
	})

	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("create file %v: %v", filename, err)
	}

	err = decorator.Fprint(file, f)
	if err != nil {
		log.Fatalf("format file %v: %v", filename, err)
	}
}
