//go:build tools
// +build tools

package main

import (
	"fmt"
	g "github.com/Xuanwo/go-codegen"
	"go/parser"
	"go/token"
	"os"
	"sort"
	"text/template"

	"github.com/Xuanwo/templateutils"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/jennifer/jen"
	log "github.com/sirupsen/logrus"

	"github.com/beyondstorage/go-storage/v4/cmd/definitions/bindata"
)

var (
	infoT      = newTmpl("cmd/definitions/tmpl/info")
	serviceT   = newTmpl("cmd/definitions/tmpl/service")
	operationT = newTmpl("cmd/definitions/tmpl/operation")
	functionT  = newTmpl("cmd/definitions/tmpl/function")
	objectT    = newTmpl("cmd/definitions/tmpl/object")
)

func generateGlobal(data *Data) {
	// Metas generate
	generateT(infoT, "types/info.generated.go", data)

	// Pair generate
	generateF("pairs/generated.go", generatePair(data))

	// Operation generate
	generateT(operationT, "types/operation.generated.go", data)

	// Object generate
	generateT(objectT, "types/object.generated.go", data)
}

func generateServiceViaCodegen(data *Service) {
	f := g.Group{}
	f.Comment("Code generated by go generate cmd/definitions; DO NOT EDIT.")
	f.Package(data.Name)
	f.Import("context").
		Import("io").
		Import("net/http").
		Import("time").
		Line().
		ImportDot("github.com/beyondstorage/go-storage/v4/pairs").
		Import("github.com/beyondstorage/go-storage/v4/pkg/httpclient").
		Import("github.com/beyondstorage/go-storage/v4/services").
		ImportDot("github.com/beyondstorage/go-storage/v4/types")

	f.Vars(
		g.Field("_", "Storager"),
		g.Field("_", "services.ServiceError"),
		g.Field("_", "httpclient.Options"),
		g.Field("_", "time.Duration"),
		g.Field("_", "http.Request"),
		g.Field("_", "Error"),
	)

	f.Const("Type", data.Name)

	osm := f.Struct("ObjectSystemMetadata").
		Comment("ObjectSystemMetadata stores system metadata for object.")
	for _, info := range data.Infos {
		if info.Scope != "object" {
			continue
		}
		if info.Global {
			continue
		}
		pname := templateutils.ToPascal(info.Name)
		if info.DisplayName() != "" {
			pname = info.DisplayName()
		}
		// FIXME: we will support comment on field later.
		osm.Field(pname, info.Type())
	}

	gosmfn := f.Function("GetObjectSystemMetadata").Comment(`
// GetObjectSystemMetadata will get ObjectSystemMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectServiceMetadata is read only and should not be modified.
`)
	gosmfn.Parameter("o", "*Object")
	gosmfn.Body(
		g.Decl(g.List("sm, ok"), g.String("o.GetSystemMetadata()")),
		g.If(g.String("ok")).Body(
			g.Return(g.Struct("sm.(ObjectSystemMetadata)")),
		),
		g.Return(g.Value("ObjectSystemMetadata")),
	)

	for _, ns := range data.Namespaces {
		nsName := templateutils.ToPascal(ns.Name)
		fnName := templateutils.ToPascal(ns.New.Name)

		// Generate pair struct
		pairStructName := fmt.Sprintf("pair%s%s", nsName, fnName)

		pairStruct := f.Struct(pairStructName).
			CommentF("%s is the parsed struct", pairStructName)
		pairStruct.Field("pairs", "[]Pair")

		for _, pair := range ns.New.Required {
			pairName := templateutils.ToPascal(pair.Name)

			pairStruct.Field("Has"+pairName, "bool")
			pairStruct.Field(pairName, pair.Type())
		}
		for _, pair := range ns.New.Optional {
			pairName := templateutils.ToPascal(pair.Name)

			pairStruct.Field("Has"+pairName, "bool")
			pairStruct.Field(pairName, pair.Type())
		}
		for _, feature := range ns.Features {
			pairName := templateutils.ToPascal(feature.Name)

			pairStruct.Field("has"+pairName, "bool")
			pairStruct.Field("Enable"+pairName, "bool")
		}
		for _, defalutable := range ns.Defaultable() {
			pairName := templateutils.ToPascal(defalutable.Pair.Name)

			pairStruct.Field("hasDefault"+pairName, "bool")
			pairStruct.Field("Default"+pairName, defalutable.Pair.Type())
		}

		// Generate pair parse function.
		pairFuncName := fmt.Sprintf("parsePair%s%s", nsName, fnName)

		fn := f.Function(pairFuncName).
			CommentF("%s will parse Pair slice into *%s", pairFuncName, pairStructName).
			Parameter("opts", "[]Pair").
			Result("", pairStructName).
			Result("", "error")
		fn.Body(
			g.Decl(
				g.String("result"),
				g.Value(pairStructName).Field("pairs", "opts")),
			g.For(g.String("_, v := range opts")).Body(
				func() g.Node {
					iswitch := g.Switch(g.String("v.Key"))
					for _, pair := range ns.New.Required {
						pairName := templateutils.ToPascal(pair.Name)

						iswitch.Case(g.Lit(pair.Name)).Body(
							g.If(g.StringF("result.Has%s", pairName)).Body(
								g.Continue(),
							),
							g.Assign(
								g.StringF("result.Has%s", pairName),
								g.Lit(true)),
							g.Assign(g.StringF("result.%s", pairName),
								g.StringF("v.Value.(%s)", pair.Type())),
						)
					}
					for _, pair := range ns.New.Optional {
						pairName := templateutils.ToPascal(pair.Name)

						iswitch.Case(g.Lit(pair.Name)).Body(
							g.If(g.StringF("result.Has%s", pairName)).Body(
								g.Continue(),
							),
							g.Assign(
								g.StringF("result.Has%s", pairName),
								g.Lit(true)),
							g.Assign(g.StringF("result.%s", pairName),
								g.StringF("v.Value.(%s)", pair.Type())),
						)
					}
					// TODO: features and defaultable are omitted in this demo.
					return iswitch
				}(),
			),
		)
	}
}

func generatePair(data *Data) *jen.File {
	xf := g.Group{}
	xf.Comment("Code generated by go generate cmd/definitions; DO NOT EDIT.")
	xf.Package("pairs")
	xf.Imports(
		g.Import("context"),
		g.Import("time"),
		g.Line(),
		g.Import("github.com/beyondstorage/go-storage/v4/pkg/httpclient"),
		g.ImportDot("github.com/beyondstorage/go-storage/v4/types"),
	)

	ps := make([]*Pair, 0, len(data.Pairs))
	for _, v := range data.Pairs {
		v := v
		ps = append(ps, v)
	}
	sort.SliceStable(ps, func(i, j int) bool {
		return ps[i].Name < ps[j].Name
	})

	for _, v := range ps {
		pname := templateutils.ToPascal(v.Name)

		xfn := xf.Function("With" + pname)

		xfn.CommentF(`With%s will apply %s value to Options.

%s %s`, pname, v.Name, pname, v.originalDescription)
		xfn.Parameter("v", v.Type())
		xfn.Result("p", "Pair")
		xfn.Body(
			g.Return(
				g.Value("Pair").
					Field("Key", v.Name).
					Field("Value", "v")),
		)
	}

	return nil
}

func generateF(filePath string, content *jen.File) {
	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf("create file %s: %s", filePath, err)
	}

	err = content.Render(file)
	if err != nil {
		log.Fatalf("write file %s: %s", filePath, err)
	}
}

func generateService(data *Data) {
	generateT(serviceT, "generated.go", data.Service)
	for _, v := range data.Service.Namespaces {
		appendT(functionT, v.Name+".go", v)
		formatService(v.Name + ".go")
	}
}

func generateT(tmpl *template.Template, filePath string, data interface{}) {
	errorMsg := fmt.Sprintf("generate template %s to %s", tmpl.Name(), filePath) + ": %v"

	file, err := os.Create(filePath)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
	err = tmpl.Execute(file, data)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
}

func appendT(tmpl *template.Template, filePath string, data interface{}) {
	errorMsg := fmt.Sprintf("append template %s to %s", tmpl.Name(), filePath) + ": %v"

	file, err := os.OpenFile(filePath, os.O_APPEND|os.O_RDWR, 0644)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
	err = tmpl.Execute(file, data)
	if err != nil {
		log.Fatalf(errorMsg, err)
	}
}

func newTmpl(name string) *template.Template {
	return template.Must(
		template.New(name).
			Funcs(templateutils.FuncMap()).
			Parse(string(bindata.MustAsset(name + ".tmpl"))))
}

func formatService(filename string) {
	fset := token.NewFileSet()

	f, err := decorator.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("parse file: %v", err)
	}

	// Sort all methods via name.
	// Only allow functions in service.go and storage.go
	sort.SliceStable(f.Decls, func(i, j int) bool {
		fi, ok := f.Decls[i].(*dst.FuncDecl)
		if !ok {
			return false
		}
		fj, ok := f.Decls[j].(*dst.FuncDecl)
		if !ok {
			return false
		}
		return fi.Name.Name < fj.Name.Name
	})

	// Add empty line for every methods.
	dst.Inspect(f, func(node dst.Node) bool {
		if node == nil {
			return false
		}
		fn, ok := node.(*dst.FuncDecl)
		if !ok {
			return true
		}
		fn.Decorations().Before = dst.EmptyLine
		fn.Decorations().After = dst.EmptyLine
		return true
	})

	file, err := os.Create(filename)
	if err != nil {
		log.Fatalf("create file %v: %v", filename, err)
	}

	err = decorator.Fprint(file, f)
	if err != nil {
		log.Fatalf("format file %v: %v", filename, err)
	}
}
