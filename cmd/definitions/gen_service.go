//go:build tools
// +build tools

package main

import (
	"fmt"
	"github.com/Xuanwo/gg"
	"github.com/Xuanwo/templateutils"
	log "github.com/sirupsen/logrus"
)

func generateSrv(data *Service, path string) {
	f := gg.Group()
	f.LineComment("Code generated by go generate via cmd/definitions; DO NOT EDIT.")
	f.Package(data.Name)
	f.Imports().
		Path("context").
		Path("io").
		Path("net/http").
		Path("time").
		Line().
		Dot("github.com/beyondstorage/go-storage/v4/pairs").
		Path("github.com/beyondstorage/go-storage/v4/pkg/httpclient").
		Path("github.com/beyondstorage/go-storage/v4/services").
		Dot("github.com/beyondstorage/go-storage/v4/types")

	f.Var().
		Decl("_", "Storager").
		Decl("_", "services.ServiceError").
		Decl("_", "httpclient.Options").
		Decl("_", "time.Duration").
		Decl("_", "http.Request").
		Decl("_", "Error")

	f.LineComment("Type is the type for %s", data.Name)
	f.Const().Field("Type", gg.Lit(data.Name).String())

	// Generate object system metadata.
	f.LineComment("ObjectSystemMetadata stores system metadata for object.")
	osm := f.Struct("ObjectSystemMetadata")
	for _, info := range data.Infos {
		if info.Scope != "object" {
			continue
		}
		if info.Global {
			continue
		}
		pname := templateutils.ToPascal(info.Name)
		if info.DisplayName() != "" {
			pname = info.DisplayName()
		}
		// FIXME: we will support comment on field later.
		osm.Field(pname, info.Type())
	}

	gosmfn := f.Function("GetObjectSystemMetadata").LineComment(`
GetObjectSystemMetadata will get ObjectSystemMetadata from Object.

- This function should not be called by service implementer.
- The returning ObjectServiceMetadata is read only and should not be modified.
`)
	gosmfn.Parameter("o", "*Object").
		Result("", "ObjectSystemMetadata")
	gosmfn.Body(
		gg.S("sm, ok := o.GetSystemMetadata()"),
		gg.If(gg.S("ok")).
			Body(gg.Return("sm.(ObjectSystemMetadata)")),
		gg.Return(gg.Value("ObjectSystemMetadata")),
	)

	sosmfn := f.Function("setObjectSystemMetadata").LineComment(`
setObjectSystemMetadata will set ObjectSystemMetadata into Object.

- This function should only be called once, please make sure all data has been written before set.
`)
	sosmfn.Parameter("o", "*Object").
		Parameter("sm", "ObjectSystemMetadata")
	sosmfn.Body(
		gg.S("o.SetSystemMetadata(sm)"),
	)

	// Generate storage system metadata.
	f.LineComment("StorageSystemMetadata stores system metadata for object.")
	ssm := f.Struct("StorageSystemMetadata")
	for _, info := range data.Infos {
		if info.Scope != "object" {
			continue
		}
		if info.Global {
			continue
		}
		pname := templateutils.ToPascal(info.Name)
		if info.DisplayName() != "" {
			pname = info.DisplayName()
		}
		// FIXME: we will support comment on field later.
		ssm.Field(pname, info.Type())
	}

	gssmfn := f.Function("GetStorageSystemMetadata").LineComment(`
GetStorageSystemMetadata will get StorageSystemMetadata from Storage.

- This function should not be called by service implementer.
- The returning StorageServiceMetadata is read only and should not be modified.
`)
	gssmfn.Parameter("s", "*StorageMeta").
		Result("", "StorageSystemMetadata")
	gssmfn.Body(
		gg.S("sm, ok := s.GetSystemMetadata()"),
		gg.If(gg.S("ok")).
			Body(gg.Return("sm.(StorageSystemMetadata)")),
		gg.Return(gg.Value("StorageSystemMetadata")),
	)

	sssmfn := f.Function("setStorageSystemMetadata").LineComment(`
setStorageSystemMetadata will set StorageSystemMetadata into Storage.

- This function should only be called once, please make sure all data has been written before set.
`)
	sssmfn.Parameter("s", "*StorageMeta").
		Parameter("sm", "StorageSystemMetadata")
	sssmfn.Body(
		gg.S("s.SetSystemMetadata(sm)"),
	)

	// Generate service pairs.
	for _, pair := range data.Pairs() {
		// We don't need to generate global pairs here.
		if pair.Global {
			continue
		}

		pname := templateutils.ToPascal(pair.Name)

		fn := f.Function("With"+pname).
			NamedLineComment(`will apply %s value to Options.

%s`, pair.Name, pair.Description)

		// Set to true as default.
		value := "true"
		// bool type pairs don't need input.
		if pair.Type() != "bool" {
			fn.Parameter("v", pair.Type())
			value = "v"
		}
		fn.Result("", "Pair")
		fn.Body(gg.Return(
			gg.Value("Pair").
				Field("Key", gg.Lit(pair.Name)).
				Field("Value", value)))
	}

	// Generate pair map
	f.Var().Field("pairMap", gg.Embed(func() gg.Node {
		i := gg.Value("map[string]string")
		for _, pair := range data.Pairs() {
			i.Field(gg.Lit(pair.Name), gg.Lit(pair.Type()))
		}
		return i
	}))

	// Generate every namespace.
	for _, ns := range data.Namespaces {
		nsNameP := templateutils.ToPascal(ns.Name)

		// Generate interface assert.
		inters := f.Var()
		for _, inter := range ns.Interfaces {
			interNameP := templateutils.ToPascal(inter.Name)
			inters.TypedField(
				"_", interNameP, gg.S("&%s{}", nsNameP))
		}

		// Generate feature struct.
		features := f.Struct(nsNameP + "Features")
		for _, fs := range ns.Features {
			features.LineComment(fs.Description)
			features.Field(templateutils.ToPascal(fs.Name), "bool")
		}

		// Generate pair new.
		fnNewNameP := templateutils.ToPascal(ns.New.Name)
		partStructName := fmt.Sprintf("pair%s%s", nsNameP, fnNewNameP)
		f.LineComment("%s is the parsed struct", partStructName)
		pairStruct := f.Struct(partStructName).
			Field("pairs", "[]Pair").
			Line()

		// Generate required pairs.
		pairStruct.LineComment("Required pairs")
		for _, pair := range ns.New.Required {
			pairNameP := templateutils.ToPascal(pair.Name)
			pairStruct.Field("Has"+pairNameP, "bool")
			pairStruct.Field(pairNameP, pair.Type())
		}

		// Generate optional pairs.
		pairStruct.LineComment("Optional pairs")
		for _, pair := range ns.New.Optional {
			pairNameP := templateutils.ToPascal(pair.Name)
			pairStruct.Field("Has"+pairNameP, "bool")
			pairStruct.Field(pairNameP, pair.Type())
		}

		// Generate feature handle logic.
		pairStruct.LineComment("Enable features")
		for _, feature := range ns.Features {
			featureNameP := templateutils.ToPascal(feature.Name)
			pairStruct.Field("hasEnable"+featureNameP, "bool")
			pairStruct.Field("Enable"+featureNameP, "bool")
		}

		// Generate default pairs.
		pairStruct.LineComment("Default pairs")
		for _, dp := range ns.Defaultable() {
			dpNameP := templateutils.ToPascal(dp.Pair.Name)
			pairStruct.Field("hasDefault"+dpNameP, "bool")
			pairStruct.Field("Default"+dpNameP, dp.Pair.Type())
		}

		// Generate parse newPair.
		pairParseName := fmt.Sprintf("parsePair%s%s", nsNameP, fnNewNameP)
		f.LineComment("%s will parse Pair slice into *%s", pairParseName, partStructName)
		pairParse := f.Function(pairParseName).
			Parameter("opts", "[]Pair").
			Result("", partStructName).
			Result("", "error")
		pairParse.Body(
			gg.S("result :="),
			gg.Value(partStructName).Field("pairs", "opts"),
			gg.Line(),
			gg.For(gg.S("_, v := range opts")).
				Body(gg.Embed(func() gg.Node {
					is := gg.Switch(gg.S("v.Key"))

					for _, pair := range ns.New.Required {
						pairNameP := templateutils.ToPascal(pair.Name)
						is.Case(gg.Lit(pair.Name)).Body(
							gg.If(gg.S("result.Has%s", pairNameP)).
								Body(gg.Continue()),
							gg.S("result.Has%s = true", pairNameP),
							gg.S("result.%s = v.Value.(%s)", pairNameP, pair.Type()),
						)
					}
					for _, pair := range ns.New.Optional {
						pairNameP := templateutils.ToPascal(pair.Name)
						is.Case(gg.Lit(pair.Name)).Body(
							gg.If(gg.S("result.Has%s", pairNameP)).
								Body(gg.Continue()),
							gg.S("result.Has%s = true", pairNameP),
							gg.S("result.%s = v.Value.(%s)", pairNameP, pair.Type()),
						)
					}
					for _, feature := range ns.Features {
						featureNameP := templateutils.ToPascal(feature.Name)
						is.Case(gg.Lit("enable_"+feature.Name)).Body(
							gg.If(gg.S("result.hasEnable%s", featureNameP)).
								Body(gg.Continue()),
							gg.S("result.hasEnable%s = true", featureNameP),
							gg.S("result.Enable%s = true", featureNameP),
						)
					}
					for _, dp := range ns.Defaultable() {
						dpNameP := templateutils.ToPascal(dp.Pair.Name)
						is.Case(gg.Lit("default_"+dp.Pair.Name)).Body(
							gg.If(gg.S("result.hasDefault%s", dpNameP)).
								Body(gg.Continue()),
							gg.S("result.hasDefault%s = true", dpNameP),
							gg.S("result.Default%s = v.Value.(%s)", dpNameP, dp.Pair.Type()),
						)
					}
					return is
				})),
			gg.LineComment("Enable features"),
			gg.Embed(func() gg.Node {
				// Generate features enable here.
				group := gg.Group()
				for _, feature := range ns.Features {
					featureNameP := templateutils.ToPascal(feature.Name)

					gg.If(gg.S("result.hasEnable%s", featureNameP)).
						Body(
							gg.S("result.Has%sFeatures = true", nsNameP),
							gg.S("result.%sFeatures.%s = true", nsNameP, featureNameP),
						)
				}
				return group
			}),
			gg.Embed(func() gg.Node {
				// Generate default pari handle logic here.
				group := gg.Group()
				for _, dp := range ns.Defaultable() {
					pairNameP := templateutils.ToPascal(dp.Pair.Name)

					xif := group.
						If(gg.S("result.hasDefault%s", pairNameP)).
						Body(gg.S("result.HasDefault%sPairs = true", nsNameP))
					for _, op := range dp.Funcs {
						opN := templateutils.ToPascal(op)

						xif.Body(gg.S(
							"result.Default%sPairs.%s = append(result.Default%sPairs.%s, With%s(result.Default%s))",
							nsNameP, opN, nsNameP, opN, pairNameP, pairNameP))
					}
				}
				return group
			}),
			gg.Embed(func() gg.Node {
				// Generate required validate logic here.
				group := gg.Group()

				for _, pair := range ns.New.Required {
					pairNameP := templateutils.ToPascal(pair.Name)
					group.If(gg.S("!result.Has%s", pairNameP)).
						Body(gg.S(
							`return pair%s%s{}, services.PairRequiredError{ Keys:[]string{ "%s" } }`,
							nsNameP, fnNewNameP, pair.Name))
				}
				return group
			}),
			gg.Return("result", "nil"),
		)

		// Generate default pairs.
		f.LineComment("Default%sPairs is default pairs for specific action", nsNameP)
		dps := f.Struct(fmt.Sprintf("Default%sPairs", nsNameP))
		for _, fn := range ns.Funcs {
			fnNameP := templateutils.ToPascal(fn.Name)
			dps.Field(fnNameP, "[]Pair")
		}

		// Generate pair.
		for _, fn := range ns.Funcs {
			fnNameP := templateutils.ToPascal(fn.Name)
			pairStructName := fmt.Sprintf("pair%s%s", nsNameP, fnNameP)

			// Generate pair struct
			pairStruct := f.Struct(pairStructName).
				Field("pairs", "[]Pair")

			// Generate required pairs.
			pairStruct.LineComment("Required pairs")
			for _, pair := range fn.Required {
				pairNameP := templateutils.ToPascal(pair.Name)
				pairStruct.Field("Has"+pairNameP, "bool")
				pairStruct.Field(pairNameP, pair.Type())
			}

			// Generate optional pairs.
			pairStruct.LineComment("Optional pairs")
			for _, pair := range fn.Optional {
				pairNameP := templateutils.ToPascal(pair.Name)
				pairStruct.Field("Has"+pairNameP, "bool")
				pairStruct.Field(pairNameP, pair.Type())
			}

			pairParseName := fmt.Sprintf("parsePair%s%s", nsNameP, fnNameP)
			pairParse := f.Function(pairParseName).
				Receiver("s", "*"+nsNameP).
				Parameter("opts", "[]Pair").
				Result("", pairStructName).
				Result("", "error")
			pairParse.Body(
				gg.S("result :="),
				gg.Value(pairStructName).Field("pairs", "opts"),
				gg.Line(),
				gg.For(gg.S("_, v := range opts")).
					Body(gg.Embed(func() gg.Node {
						is := gg.Switch(gg.S("v.Key"))

						for _, pair := range fn.Required {
							pairNameP := templateutils.ToPascal(pair.Name)
							is.Case(gg.Lit(pair.Name)).Body(
								gg.If(gg.S("result.Has%s", pairNameP)).
									Body(gg.Continue()),
								gg.S("result.Has%s = true", pairNameP),
								gg.S("result.%s = v.Value.(%s)", pairNameP, pair.Type()),
							)
						}
						for _, pair := range fn.Optional {
							pairNameP := templateutils.ToPascal(pair.Name)
							is.Case(gg.Lit(pair.Name)).Body(
								gg.If(gg.S("result.Has%s", pairNameP)).
									Body(gg.Continue()),
								gg.S("result.Has%s = true", pairNameP),
								gg.S("result.%s = v.Value.(%s)", pairNameP, pair.Type()),
							)
						}
						dcas := is.Default()
						if ns.HasFeatureLoosePair {
							dcas.Body(
								gg.LineComment(`
loose_pair feature introduced in GSP-109.
If user enable this feature, service should ignore not support pair error.`),
								gg.If(gg.S("s.features.LoosePair")).
									Body(gg.Continue()),
							)
						}
						dcas.Body(gg.S("return pair%s%s{}, services.PairUnsupportedError{Pair:v}", nsNameP, fnNameP))
						return is
					})),

				gg.Embed(func() gg.Node {
					// Generate required validate logic here.
					group := gg.Group()

					for _, pair := range fn.Required {
						pairNameP := templateutils.ToPascal(pair.Name)
						group.If(gg.S("!result.Has%s", pairNameP)).
							Body(gg.S(
								`return pair%s%s{}, services.PairRequiredError{ Keys:[]string{ "%s" } }`,
								nsNameP, fnNameP, pair.Name))
					}
					return group
				}),
				gg.Return("result", "nil"),
			)
		}

		// Generate public functions.
		for _, fn := range ns.Funcs {
			fnNameP := templateutils.ToPascal(fn.Name)
			if fn.Local {
				// Generate a local function.
				xfn := f.Function(fnNameP).Receiver("s", "*"+nsNameP)
				for _, field := range fn.Params {
					xfn.Parameter(field.Name, field.Type())
				}
				for _, field := range fn.Results {
					xfn.Result(field.Name, field.Type())
				}
				xfn.Body(
					gg.S("pairs = append(pairs, s.defaultPairs.%s...)", fnNameP),
					gg.S("var opt pair%s%s", nsNameP, fnNameP),
					gg.Line(),
					gg.LineComment("Ignore error while handling local functions."),
					gg.S("opt, _ = s.parsePair%s%s(pairs)", nsNameP, fnNameP),
					gg.Return(
						gg.Embed(func() gg.Node {
							ic := gg.Call(templateutils.ToCamel(fn.Name)).
								Owner("s")
							for _, v := range fn.Params {
								// We don't need to call pair again.
								if v.Type() == "...Pair" {
									continue
								}
								ic.Parameter(v.Name)
							}
							ic.Parameter("opt")
							return ic
						})))
				continue
			}
			// Generate a non-local function.
			// TODO: generate comment here.
			xfn := f.Function(fnNameP).
				Receiver("s", "*"+nsNameP)
			for _, field := range fn.Params {
				xfn.Parameter(field.Name, field.Type())
			}
			for _, field := range fn.Results {
				xfn.Result(field.Name, field.Type())
			}
			xfn.Body(
				"ctx := context.Background()",
				gg.Return(
					gg.Embed(func() gg.Node {
						ic := gg.Call(fnNameP + "WithContext").
							Owner("s")
						ic.Parameter("ctx")
						for _, v := range fn.Params {
							if v.Type() == "...Pair" {
								ic.Parameter("pairs...")
								continue
							}
							ic.Parameter(v.Name)
						}
						return ic
					})))

			xfn = f.Function(fnNameP+"WithContext").
				Receiver("s", "*"+nsNameP)
			xfn.Parameter("ctx", "context.Context")
			for _, field := range fn.Params {
				xfn.Parameter(field.Name, field.Type())
			}
			for _, field := range fn.Results {
				xfn.Result(field.Name, field.Type())
			}
			xfn.Body(
				gg.Defer(gg.Embed(func() gg.Node {
					caller := gg.Call("formatError").Owner("s")
					caller.Parameter(gg.Lit(fn.Name)).Parameter("err")
					for _, v := range fn.Params {
						// formatError only accept string as input.
						if v.Type() != "string" {
							continue
						}
						caller.Parameter(v.Name)
					}

					fn := gg.Function("").
						Body(gg.S("err = "), caller)

					fn.Call()
					return fn
				})),
				gg.Embed(func() gg.Node {
					if fn.ObjectMode == "" {
						return gg.Line()
					}
					mode := templateutils.ToPascal(fn.ObjectMode)
					return gg.If(gg.S("!o.Mode.Is%s()", mode)).Body(
						gg.S("err = services.ObjectModeInvalidError{Expected: Mode%s, Actual: o.Mode}", mode),
						gg.Return(),
					)
				}),
				gg.S("pairs = append(pairs, s.defaultPairs.%s...)", fnNameP),
				gg.S("var opt pair%s%s", nsNameP, fnNameP),
				gg.Line(),
				gg.S("opt, err = s.parsePair%s%s(pairs)", nsNameP, fnNameP),
				gg.If(gg.S("err != nil")).Body(gg.Return()),
				gg.Return(
					gg.Embed(func() gg.Node {
						ic := gg.Call(templateutils.ToCamel(fn.Name)).
							Owner("s")
						ic.Parameter("ctx")
						for _, v := range fn.Params {
							// We don't need to call pair again.
							if v.Type() == "...Pair" {
								continue
							}
							ic.Parameter(v.Name)
						}
						ic.Parameter("opt")
						return ic
					})))
		}
	}

	// Generate init function
	initFn := f.Function("init")
	for _, ns := range data.Namespaces {
		nsNameP := templateutils.ToPascal(ns.Name)
		initFn.Body(gg.Call("Register" + nsNameP + "r").
			Owner("services").
			Parameter("Type").
			Parameter("New" + nsNameP + "r"))
	}
	initFn.Body("services.RegisterSchema(Type, pairMap)")

	err := f.WriteFile(path)
	if err != nil {
		log.Fatalf("generate to %s: %v", path, err)
	}
}
