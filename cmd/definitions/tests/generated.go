// Code generated by go generate via cmd/definitions; DO NOT EDIT.
package tests

import (
	"context"
	"io"
	"net/http"
	"strings"
	"time"

	. "go.beyondstorage.io/v5/pairs"
	"go.beyondstorage.io/v5/pkg/httpclient"
	"go.beyondstorage.io/v5/services"
	"go.beyondstorage.io/v5/types"
)

var (
	_ types.Storager
	_ services.ServiceError
	_ httpclient.Options
	_ time.Duration
	_ http.Request
	_ Error
)

// Type is the type for tests
const Type = "tests"

// ObjectSystemMetadata stores system metadata for object.
type ObjectSystemMetadata struct {
	StorageClass string
}

// GetObjectSystemMetadata will get ObjectSystemMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectServiceMetadata is read only and should not be modified.
func GetObjectSystemMetadata(o *types.Object) ObjectSystemMetadata {
	sm, ok := o.GetSystemMetadata()
	if ok {
		return sm.(ObjectSystemMetadata)
	}
	return ObjectSystemMetadata{}
}

// setObjectSystemMetadata will set ObjectSystemMetadata into Object.
//
// - This function should only be called once, please make sure all data has been written before set.
func setObjectSystemMetadata(o *types.Object, sm ObjectSystemMetadata) {
	o.SetSystemMetadata(sm)
}

// StorageSystemMetadata stores system metadata for object.
type StorageSystemMetadata struct {
	StorageClass string
}

// GetStorageSystemMetadata will get StorageSystemMetadata from Storage.
//
// - This function should not be called by service implementer.
// - The returning StorageServiceMetadata is read only and should not be modified.
func GetStorageSystemMetadata(s *types.StorageMeta) StorageSystemMetadata {
	sm, ok := s.GetSystemMetadata()
	if ok {
		return sm.(StorageSystemMetadata)
	}
	return StorageSystemMetadata{}
}

// setStorageSystemMetadata will set StorageSystemMetadata into Storage.
//
// - This function should only be called once, please make sure all data has been written before set.
func setStorageSystemMetadata(s *types.StorageMeta, sm StorageSystemMetadata) {
	s.SetSystemMetadata(sm)
}

// WithDefaultServicePairs will apply default_service_pairs value to Options.
func WithDefaultServicePairs(v DefaultServicePairs) types.Pair {
	return types.Pair{Key: "default_service_pairs", Value: v}
}

// WithDefaultStorageClass will apply default_storage_class value to Options.
func WithDefaultStorageClass(v string) types.Pair {
	return types.Pair{Key: "default_storage_class", Value: v}
}

// WithDefaultStoragePairs will apply default_storage_pairs value to Options.
func WithDefaultStoragePairs(v DefaultStoragePairs) types.Pair {
	return types.Pair{Key: "default_storage_pairs", Value: v}
}

// WithDisableURICleaning will apply disable_uri_cleaning value to Options.
func WithDisableURICleaning() types.Pair {
	return types.Pair{Key: "disable_uri_cleaning", Value: true}
}

// WithEnableLoosePair will apply enable_loose_pair value to Options.
//
// loose_pair feature is designed for users who don't want strict pair checks.
//
// If this feature is enabled, the service will not return an error for not support pairs.
//
// This feature was introduced in GSP-109.
func WithEnableLoosePair() types.Pair {
	return types.Pair{Key: "enable_loose_pair", Value: true}
}

// WithEnableVirtualDir will apply enable_virtual_dir value to Options.
//
// virtual_dir feature is designed for a service that doesn't have native dir support but wants to
// provide simulated operations.
//
// - If this feature is disabled (the default behavior), the service will behave like it doesn't have
// any dir support.
// - If this feature is enabled, the service will support simulated dir behavior in create_dir, create,
// list, delete, and so on.
//
// This feature was introduced in GSP-109.
func WithEnableVirtualDir() types.Pair {
	return types.Pair{Key: "enable_virtual_dir", Value: true}
}

// WithServiceFeatures will apply service_features value to Options.
//
// Deprecated: Use service_virtual_features instead.
func WithServiceFeatures(v ServiceFeatures) types.Pair {
	return types.Pair{Key: "service_features", Value: v}
}

// WithServiceVirtualFeatures will apply service_virtual_features value to Options.
func WithServiceVirtualFeatures(v ServiceVirtualFeatures) types.Pair {
	return types.Pair{Key: "service_virtual_features", Value: v}
}

// WithStorageClass will apply storage_class value to Options.
func WithStorageClass(v string) types.Pair {
	return types.Pair{Key: "storage_class", Value: v}
}

// WithStorageFeatures will apply storage_features value to Options.
//
// Deprecated: Use storage_virtual_features instead.
func WithStorageFeatures(v StorageFeatures) types.Pair {
	return types.Pair{Key: "storage_features", Value: v}
}

// WithStorageVirtualFeatures will apply storage_virtual_features value to Options.
func WithStorageVirtualFeatures(v StorageVirtualFeatures) types.Pair {
	return types.Pair{Key: "storage_virtual_features", Value: v}
}

// WithStringPair will apply string_pair value to Options.
//
// tests connection string
func WithStringPair(v string) types.Pair {
	return types.Pair{Key: "string_pair", Value: v}
}

var pairMap = map[string]string{"content_disposition": "string", "content_md5": "string", "content_type": "string", "context": "context.Context", "continuation_token": "string", "credential": "string", "default_content_type": "string", "default_io_callback": "func([]byte)", "default_service_pairs": "DefaultServicePairs", "default_storage_class": "string", "default_storage_pairs": "DefaultStoragePairs", "disable_uri_cleaning": "bool", "enable_loose_pair": "bool", "enable_virtual_dir": "bool", "endpoint": "string", "http_client_options": "*httpclient.Options", "interceptor": "types.Interceptor", "io_callback": "func([]byte)", "list_mode": "types.ListMode", "location": "string", "multipart_id": "string", "name": "string", "object_mode": "types.ObjectMode", "offset": "int64", "service_features": "ServiceFeatures", "service_virtual_features": "ServiceVirtualFeatures", "size": "int64", "storage_class": "string", "storage_features": "StorageFeatures", "storage_virtual_features": "StorageVirtualFeatures", "string_pair": "string", "work_dir": "string"}
var _ types.Servicer = &Service{}

// Deprecated: Use ServiceVirtualFeatures instead.
type ServiceFeatures struct {
}
type ServiceVirtualFeatures struct {
}

// pairServiceNew is the parsed struct
type pairServiceNew struct {
	pairs []types.Pair

	// Required pairs
	HasCredential bool
	Credential    string
	// Optional pairs
	HasDefaultServicePairs    bool
	DefaultServicePairs       DefaultServicePairs
	HasEndpoint               bool
	Endpoint                  string
	HasHTTPClientOptions      bool
	HTTPClientOptions         *httpclient.Options
	HasServiceFeatures        bool
	ServiceFeatures           ServiceFeatures
	HasServiceVirtualFeatures bool
	ServiceVirtualFeatures    ServiceVirtualFeatures
	// Enable virtual features
}

// parsePairServiceNew will parse Pair slice into *pairServiceNew
func parsePairServiceNew(opts []types.Pair) (pairServiceNew, error) {
	result :=
		pairServiceNew{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "credential":
			if result.HasCredential {
				continue
			}
			result.HasCredential = true
			result.Credential = v.Value.(string)
		case "default_service_pairs":
			if result.HasDefaultServicePairs {
				continue
			}
			result.HasDefaultServicePairs = true
			result.DefaultServicePairs = v.Value.(DefaultServicePairs)
		case "endpoint":
			if result.HasEndpoint {
				continue
			}
			result.HasEndpoint = true
			result.Endpoint = v.Value.(string)
		case "http_client_options":
			if result.HasHTTPClientOptions {
				continue
			}
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case "service_features":
			if result.HasServiceFeatures {
				continue
			}
			result.HasServiceFeatures = true
			result.ServiceFeatures = v.Value.(ServiceFeatures)
		case "service_virtual_features":
			if result.HasServiceVirtualFeatures {
				continue
			}
			result.HasServiceVirtualFeatures = true
			result.ServiceVirtualFeatures = v.Value.(ServiceVirtualFeatures)
		}
	}
	// Enable virtual features

	// Default pairs

	if !result.HasCredential {
		return pairServiceNew{}, services.PairRequiredError{Keys: []string{"credential"}}
	}
	return result, nil
}

// DefaultServicePairs is default pairs for specific action
type DefaultServicePairs struct {
	Create   []types.Pair
	Delete   []types.Pair
	Features []types.Pair
	Get      []types.Pair
	List     []types.Pair
}
type pairServiceCreate struct {
	pairs []types.Pair
	// Required pairs
	HasLocation bool
	Location    string
	// Optional pairs
}

func (s *Service) parsePairServiceCreate(opts []types.Pair) (pairServiceCreate, error) {
	result :=
		pairServiceCreate{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceCreate{}, services.PairUnsupportedError{Pair: v}
		}
	}
	if !result.HasLocation {
		return pairServiceCreate{}, services.PairRequiredError{Keys: []string{"location"}}
	}
	return result, nil
}

type pairServiceDelete struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
}

func (s *Service) parsePairServiceDelete(opts []types.Pair) (pairServiceDelete, error) {
	result :=
		pairServiceDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairServiceGet struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
}

func (s *Service) parsePairServiceGet(opts []types.Pair) (pairServiceGet, error) {
	result :=
		pairServiceGet{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceGet{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairServiceList struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
}

func (s *Service) parsePairServiceList(opts []types.Pair) (pairServiceList, error) {
	result :=
		pairServiceList{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceList{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}
func (s *Service) Create(name string, pairs ...types.Pair) (store types.Storager, err error) {
	ctx := context.Background()
	return s.CreateWithContext(ctx, name, pairs...)
}
func (s *Service) CreateWithContext(ctx context.Context, name string, pairs ...types.Pair) (store types.Storager, err error) {
	defer func() {
		err =
			s.formatError("create", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairServiceCreate

	opt, err = s.parsePairServiceCreate(pairs)
	if err != nil {
		return
	}
	return s.create(ctx, name, opt)
}
func (s *Service) Delete(name string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, name, pairs...)
}
func (s *Service) DeleteWithContext(ctx context.Context, name string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("delete", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairServiceDelete

	opt, err = s.parsePairServiceDelete(pairs)
	if err != nil {
		return
	}
	return s.delete(ctx, name, opt)
}
func (s *Service) Features() (srvf types.ServiceFeatures) {
	return
}
func (s *Service) Get(name string, pairs ...types.Pair) (store types.Storager, err error) {
	ctx := context.Background()
	return s.GetWithContext(ctx, name, pairs...)
}
func (s *Service) GetWithContext(ctx context.Context, name string, pairs ...types.Pair) (store types.Storager, err error) {
	defer func() {
		err =
			s.formatError("get", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Get...)
	var opt pairServiceGet

	opt, err = s.parsePairServiceGet(pairs)
	if err != nil {
		return
	}
	return s.get(ctx, name, opt)
}
func (s *Service) List(pairs ...types.Pair) (sti *types.StoragerIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, pairs...)
}
func (s *Service) ListWithContext(ctx context.Context, pairs ...types.Pair) (sti *types.StoragerIterator, err error) {
	defer func() {
		err =
			s.formatError("list", err, "")
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairServiceList

	opt, err = s.parsePairServiceList(pairs)
	if err != nil {
		return
	}
	return s.list(ctx, opt)
}

var _ types.Storager = &Storage{}

// Deprecated: Use StorageVirtualFeatures instead.
type StorageFeatures struct { // loose_pair feature is designed for users who don't want strict pair checks.
	//
	// If this feature is enabled, the service will not return an error for not support pairs.
	//
	// This feature was introduced in GSP-109.
	LoosePair bool
	// virtual_dir feature is designed for a service that doesn't have native dir support but wants to
	// provide simulated operations.
	//
	// - If this feature is disabled (the default behavior), the service will behave like it doesn't have
	// any dir support.
	// - If this feature is enabled, the service will support simulated dir behavior in create_dir, create,
	// list, delete, and so on.
	//
	// This feature was introduced in GSP-109.
	VirtualDir bool
	// write_empty_object feature is designed for a service that support write empty object.
	//
	// This behavior was defined in GSP-751 and classified as an operation-related feature in GSP-837.
	WriteEmptyObject bool
}
type StorageVirtualFeatures struct { // loose_pair feature is designed for users who don't want strict pair checks.
	//
	// If this feature is enabled, the service will not return an error for not support pairs.
	//
	// This feature was introduced in GSP-109.
	LoosePair bool
	// virtual_dir feature is designed for a service that doesn't have native dir support but wants to
	// provide simulated operations.
	//
	// - If this feature is disabled (the default behavior), the service will behave like it doesn't have
	// any dir support.
	// - If this feature is enabled, the service will support simulated dir behavior in create_dir, create,
	// list, delete, and so on.
	//
	// This feature was introduced in GSP-109.
	VirtualDir bool
	// write_empty_object feature is designed for a service that support write empty object.
	//
	// This behavior was defined in GSP-751 and classified as an operation-related feature in GSP-837.
	WriteEmptyObject bool
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []types.Pair

	// Required pairs
	HasName bool
	Name    string
	// Optional pairs
	HasDefaultContentType     bool
	DefaultContentType        string
	HasDefaultIoCallback      bool
	DefaultIoCallback         func([]byte)
	HasDefaultStorageClass    bool
	DefaultStorageClass       string
	HasDefaultStoragePairs    bool
	DefaultStoragePairs       DefaultStoragePairs
	HasDisableURICleaning     bool
	DisableURICleaning        bool
	HasHTTPClientOptions      bool
	HTTPClientOptions         *httpclient.Options
	HasLocation               bool
	Location                  string
	HasStorageFeatures        bool
	StorageFeatures           StorageFeatures
	HasStorageVirtualFeatures bool
	StorageVirtualFeatures    StorageVirtualFeatures
	HasWorkDir                bool
	WorkDir                   string
	// Enable virtual features
	hasEnableLoosePair  bool
	EnableLoosePair     bool
	hasEnableVirtualDir bool
	EnableVirtualDir    bool
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []types.Pair) (pairStorageNew, error) {
	result :=
		pairStorageNew{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "name":
			if result.HasName {
				continue
			}
			result.HasName = true
			result.Name = v.Value.(string)
		case "default_content_type":
			if result.HasDefaultContentType {
				continue
			}
			result.HasDefaultContentType = true
			result.DefaultContentType = v.Value.(string)
		case "default_io_callback":
			if result.HasDefaultIoCallback {
				continue
			}
			result.HasDefaultIoCallback = true
			result.DefaultIoCallback = v.Value.(func([]byte))
		case "default_storage_class":
			if result.HasDefaultStorageClass {
				continue
			}
			result.HasDefaultStorageClass = true
			result.DefaultStorageClass = v.Value.(string)
		case "default_storage_pairs":
			if result.HasDefaultStoragePairs {
				continue
			}
			result.HasDefaultStoragePairs = true
			result.DefaultStoragePairs = v.Value.(DefaultStoragePairs)
		case "disable_uri_cleaning":
			if result.HasDisableURICleaning {
				continue
			}
			result.HasDisableURICleaning = true
			result.DisableURICleaning = v.Value.(bool)
		case "http_client_options":
			if result.HasHTTPClientOptions {
				continue
			}
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		case "storage_features":
			if result.HasStorageFeatures {
				continue
			}
			result.HasStorageFeatures = true
			result.StorageFeatures = v.Value.(StorageFeatures)
		case "storage_virtual_features":
			if result.HasStorageVirtualFeatures {
				continue
			}
			result.HasStorageVirtualFeatures = true
			result.StorageVirtualFeatures = v.Value.(StorageVirtualFeatures)
		case "work_dir":
			if result.HasWorkDir {
				continue
			}
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
		case "enable_loose_pair":
			if result.hasEnableLoosePair {
				continue
			}
			result.hasEnableLoosePair = true
			result.EnableLoosePair = true
		case "enable_virtual_dir":
			if result.hasEnableVirtualDir {
				continue
			}
			result.hasEnableVirtualDir = true
			result.EnableVirtualDir = true
		}
	}
	// Enable virtual features
	if result.hasEnableLoosePair {
		result.HasStorageFeatures = true
		result.StorageFeatures.LoosePair = true
		result.HasStorageVirtualFeatures = true
		result.StorageVirtualFeatures.LoosePair = true
	}
	if result.hasEnableVirtualDir {
		result.HasStorageFeatures = true
		result.StorageFeatures.VirtualDir = true
		result.HasStorageVirtualFeatures = true
		result.StorageVirtualFeatures.VirtualDir = true
	}
	// Default pairs
	if result.HasDefaultContentType {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithContentType(result.DefaultContentType))
	}
	if result.HasDefaultIoCallback {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.Read = append(result.DefaultStoragePairs.Read, WithIoCallback(result.DefaultIoCallback))
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithIoCallback(result.DefaultIoCallback))
	}
	if result.HasDefaultStorageClass {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithStorageClass(result.DefaultStorageClass))
	}
	if !result.HasName {
		return pairStorageNew{}, services.PairRequiredError{Keys: []string{"name"}}
	}
	return result, nil
}

// DefaultStoragePairs is default pairs for specific action
type DefaultStoragePairs struct {
	CombineBlock                   []types.Pair
	CommitAppend                   []types.Pair
	CompleteMultipart              []types.Pair
	Copy                           []types.Pair
	Create                         []types.Pair
	CreateAppend                   []types.Pair
	CreateBlock                    []types.Pair
	CreateDir                      []types.Pair
	CreateLink                     []types.Pair
	CreateMultipart                []types.Pair
	CreatePage                     []types.Pair
	Delete                         []types.Pair
	Features                       []types.Pair
	Fetch                          []types.Pair
	List                           []types.Pair
	ListBlock                      []types.Pair
	ListMultipart                  []types.Pair
	Metadata                       []types.Pair
	Move                           []types.Pair
	QuerySignHTTPCompleteMultipart []types.Pair
	QuerySignHTTPCreateMultipart   []types.Pair
	QuerySignHTTPDelete            []types.Pair
	QuerySignHTTPListMultipart     []types.Pair
	QuerySignHTTPRead              []types.Pair
	QuerySignHTTPWrite             []types.Pair
	QuerySignHTTPWriteMultipart    []types.Pair
	Read                           []types.Pair
	Stat                           []types.Pair
	Write                          []types.Pair
	WriteAppend                    []types.Pair
	WriteBlock                     []types.Pair
	WriteMultipart                 []types.Pair
	WritePage                      []types.Pair
}
type pairStorageCombineBlock struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCombineBlock(opts []types.Pair) (pairStorageCombineBlock, error) {
	result :=
		pairStorageCombineBlock{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCombineBlock{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCommitAppend struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCommitAppend(opts []types.Pair) (pairStorageCommitAppend, error) {
	result :=
		pairStorageCommitAppend{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCommitAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCompleteMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCompleteMultipart(opts []types.Pair) (pairStorageCompleteMultipart, error) {
	result :=
		pairStorageCompleteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCompleteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCopy struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCopy(opts []types.Pair) (pairStorageCopy, error) {
	result :=
		pairStorageCopy{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCopy{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreate struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasObjectMode bool
	ObjectMode    types.ObjectMode
}

func (s *Storage) parsePairStorageCreate(opts []types.Pair) (pairStorageCreate, error) {
	result :=
		pairStorageCreate{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(types.ObjectMode)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreate{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateAppend struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateAppend(opts []types.Pair) (pairStorageCreateAppend, error) {
	result :=
		pairStorageCreateAppend{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreateAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateBlock struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateBlock(opts []types.Pair) (pairStorageCreateBlock, error) {
	result :=
		pairStorageCreateBlock{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreateBlock{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateDir struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateDir(opts []types.Pair) (pairStorageCreateDir, error) {
	result :=
		pairStorageCreateDir{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreateDir{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateLink struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateLink(opts []types.Pair) (pairStorageCreateLink, error) {
	result :=
		pairStorageCreateLink{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreateLink{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateMultipart(opts []types.Pair) (pairStorageCreateMultipart, error) {
	result :=
		pairStorageCreateMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreateMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreatePage struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreatePage(opts []types.Pair) (pairStorageCreatePage, error) {
	result :=
		pairStorageCreatePage{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageCreatePage{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageDelete struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasMultipartID bool
	MultipartID    string
	HasObjectMode  bool
	ObjectMode     types.ObjectMode
}

func (s *Storage) parsePairStorageDelete(opts []types.Pair) (pairStorageDelete, error) {
	result :=
		pairStorageDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(types.ObjectMode)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageFetch struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageFetch(opts []types.Pair) (pairStorageFetch, error) {
	result :=
		pairStorageFetch{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageFetch{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageList struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasListMode bool
	ListMode    types.ListMode
}

func (s *Storage) parsePairStorageList(opts []types.Pair) (pairStorageList, error) {
	result :=
		pairStorageList{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "list_mode":
			if result.HasListMode {
				continue
			}
			result.HasListMode = true
			result.ListMode = v.Value.(types.ListMode)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageList{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageListBlock struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageListBlock(opts []types.Pair) (pairStorageListBlock, error) {
	result :=
		pairStorageListBlock{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageListBlock{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageListMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageListMultipart(opts []types.Pair) (pairStorageListMultipart, error) {
	result :=
		pairStorageListMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageListMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageMetadata struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageMetadata(opts []types.Pair) (pairStorageMetadata, error) {
	result :=
		pairStorageMetadata{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageMetadata{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageMove struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageMove(opts []types.Pair) (pairStorageMove, error) {
	result :=
		pairStorageMove{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageMove{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPCompleteMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPCompleteMultipart(opts []types.Pair) (pairStorageQuerySignHTTPCompleteMultipart, error) {
	result :=
		pairStorageQuerySignHTTPCompleteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPCompleteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPCreateMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPCreateMultipart(opts []types.Pair) (pairStorageQuerySignHTTPCreateMultipart, error) {
	result :=
		pairStorageQuerySignHTTPCreateMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPCreateMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPDelete struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPDelete(opts []types.Pair) (pairStorageQuerySignHTTPDelete, error) {
	result :=
		pairStorageQuerySignHTTPDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPListMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPListMultipart(opts []types.Pair) (pairStorageQuerySignHTTPListMultipart, error) {
	result :=
		pairStorageQuerySignHTTPListMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPListMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPRead struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPRead(opts []types.Pair) (pairStorageQuerySignHTTPRead, error) {
	result :=
		pairStorageQuerySignHTTPRead{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPRead{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPWrite struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPWrite(opts []types.Pair) (pairStorageQuerySignHTTPWrite, error) {
	result :=
		pairStorageQuerySignHTTPWrite{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPWrite{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPWriteMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPWriteMultipart(opts []types.Pair) (pairStorageQuerySignHTTPWriteMultipart, error) {
	result :=
		pairStorageQuerySignHTTPWriteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageQuerySignHTTPWriteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageRead struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasIoCallback bool
	IoCallback    func([]byte)
	HasOffset     bool
	Offset        int64
	HasSize       bool
	Size          int64
}

func (s *Storage) parsePairStorageRead(opts []types.Pair) (pairStorageRead, error) {
	result :=
		pairStorageRead{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case "size":
			if result.HasSize {
				continue
			}
			result.HasSize = true
			result.Size = v.Value.(int64)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageRead{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageStat struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasObjectMode bool
	ObjectMode    types.ObjectMode
}

func (s *Storage) parsePairStorageStat(opts []types.Pair) (pairStorageStat, error) {
	result :=
		pairStorageStat{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(types.ObjectMode)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageStat{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWrite struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
	HasContentMd5   bool
	ContentMd5      string
	HasContentType  bool
	ContentType     string
	HasIoCallback   bool
	IoCallback      func([]byte)
	HasStorageClass bool
	StorageClass    string
}

func (s *Storage) parsePairStorageWrite(opts []types.Pair) (pairStorageWrite, error) {
	result :=
		pairStorageWrite{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "content_md5":
			if result.HasContentMd5 {
				continue
			}
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
		case "content_type":
			if result.HasContentType {
				continue
			}
			result.HasContentType = true
			result.ContentType = v.Value.(string)
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "storage_class":
			if result.HasStorageClass {
				continue
			}
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageWrite{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWriteAppend struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageWriteAppend(opts []types.Pair) (pairStorageWriteAppend, error) {
	result :=
		pairStorageWriteAppend{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageWriteAppend{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWriteBlock struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageWriteBlock(opts []types.Pair) (pairStorageWriteBlock, error) {
	result :=
		pairStorageWriteBlock{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageWriteBlock{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWriteMultipart struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageWriteMultipart(opts []types.Pair) (pairStorageWriteMultipart, error) {
	result :=
		pairStorageWriteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageWriteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWritePage struct {
	pairs []types.Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageWritePage(opts []types.Pair) (pairStorageWritePage, error) {
	result :=
		pairStorageWritePage{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			// loose_pair feature introduced in GSP-109.
			// If user enable this feature, service should ignore not support pair error.
			if s.features.LoosePair {
				continue
			}
			return pairStorageWritePage{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}
func (s *Storage) CombineBlock(o *types.Object, bids []string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.CombineBlockWithContext(ctx, o, bids, pairs...)
}
func (s *Storage) CombineBlockWithContext(ctx context.Context, o *types.Object, bids []string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("combine_block", err)
	}()
	if !o.Mode.IsBlock() {
		err = services.ObjectModeInvalidError{Expected: types.ModeBlock, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.CombineBlock...)
	var opt pairStorageCombineBlock

	opt, err = s.parsePairStorageCombineBlock(pairs)
	if err != nil {
		return
	}
	return s.combineBlock(ctx, o, bids, opt)
}
func (s *Storage) CommitAppend(o *types.Object, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.CommitAppendWithContext(ctx, o, pairs...)
}
func (s *Storage) CommitAppendWithContext(ctx context.Context, o *types.Object, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("commit_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: types.ModeAppend, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.CommitAppend...)
	var opt pairStorageCommitAppend

	opt, err = s.parsePairStorageCommitAppend(pairs)
	if err != nil {
		return
	}
	return s.commitAppend(ctx, o, opt)
}
func (s *Storage) CompleteMultipart(o *types.Object, parts []*types.Part, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.CompleteMultipartWithContext(ctx, o, parts, pairs...)
}
func (s *Storage) CompleteMultipartWithContext(ctx context.Context, o *types.Object, parts []*types.Part, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("complete_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: types.ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.CompleteMultipart...)
	var opt pairStorageCompleteMultipart

	opt, err = s.parsePairStorageCompleteMultipart(pairs)
	if err != nil {
		return
	}
	return s.completeMultipart(ctx, o, parts, opt)
}
func (s *Storage) Copy(src string, dst string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.CopyWithContext(ctx, src, dst, pairs...)
}
func (s *Storage) CopyWithContext(ctx context.Context, src string, dst string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("copy", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Copy...)
	var opt pairStorageCopy

	opt, err = s.parsePairStorageCopy(pairs)
	if err != nil {
		return
	}
	return s.copy(ctx, strings.ReplaceAll(src, "\\", "/"), strings.ReplaceAll(dst, "\\", "/"), opt)
}
func (s *Storage) Create(path string, pairs ...types.Pair) (o *types.Object) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairStorageCreate

	// Ignore error while handling local functions.
	opt, _ = s.parsePairStorageCreate(pairs)
	return s.create(path, opt)
}
func (s *Storage) CreateAppend(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreateAppendWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateAppendWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_append", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateAppend...)
	var opt pairStorageCreateAppend

	opt, err = s.parsePairStorageCreateAppend(pairs)
	if err != nil {
		return
	}
	return s.createAppend(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) CreateBlock(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreateBlockWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateBlockWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_block", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateBlock...)
	var opt pairStorageCreateBlock

	opt, err = s.parsePairStorageCreateBlock(pairs)
	if err != nil {
		return
	}
	return s.createBlock(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) CreateDir(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreateDirWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateDirWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_dir", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateDir...)
	var opt pairStorageCreateDir

	opt, err = s.parsePairStorageCreateDir(pairs)
	if err != nil {
		return
	}
	return s.createDir(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) CreateLink(path string, target string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreateLinkWithContext(ctx, path, target, pairs...)
}
func (s *Storage) CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_link", err, path, target)
	}()

	pairs = append(pairs, s.defaultPairs.CreateLink...)
	var opt pairStorageCreateLink

	opt, err = s.parsePairStorageCreateLink(pairs)
	if err != nil {
		return
	}
	return s.createLink(ctx, strings.ReplaceAll(path, "\\", "/"), strings.ReplaceAll(target, "\\", "/"), opt)
}
func (s *Storage) CreateMultipart(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreateMultipartWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateMultipartWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_multipart", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateMultipart...)
	var opt pairStorageCreateMultipart

	opt, err = s.parsePairStorageCreateMultipart(pairs)
	if err != nil {
		return
	}
	return s.createMultipart(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) CreatePage(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.CreatePageWithContext(ctx, path, pairs...)
}
func (s *Storage) CreatePageWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("create_page", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreatePage...)
	var opt pairStorageCreatePage

	opt, err = s.parsePairStorageCreatePage(pairs)
	if err != nil {
		return
	}
	return s.createPage(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) Delete(path string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairStorageDelete

	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}
	return s.delete(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) Features() (stof types.StorageFeatures) {
	stof.VirtualDir = true
	stof.LoosePair = true
	stof.WriteEmptyObject = true
	stof.Create = true
	stof.Delete = true
	stof.List = true
	stof.Metadata = true
	stof.Read = true
	stof.Stat = true
	stof.Write = true
	return
}
func (s *Storage) Fetch(path string, url string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.FetchWithContext(ctx, path, url, pairs...)
}
func (s *Storage) FetchWithContext(ctx context.Context, path string, url string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("fetch", err, path, url)
	}()

	pairs = append(pairs, s.defaultPairs.Fetch...)
	var opt pairStorageFetch

	opt, err = s.parsePairStorageFetch(pairs)
	if err != nil {
		return
	}
	return s.fetch(ctx, strings.ReplaceAll(path, "\\", "/"), url, opt)
}
func (s *Storage) List(path string, pairs ...types.Pair) (oi *types.ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, path, pairs...)
}
func (s *Storage) ListWithContext(ctx context.Context, path string, pairs ...types.Pair) (oi *types.ObjectIterator, err error) {
	defer func() {
		err =
			s.formatError("list", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairStorageList

	opt, err = s.parsePairStorageList(pairs)
	if err != nil {
		return
	}
	return s.list(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) ListBlock(o *types.Object, pairs ...types.Pair) (bi *types.BlockIterator, err error) {
	ctx := context.Background()
	return s.ListBlockWithContext(ctx, o, pairs...)
}
func (s *Storage) ListBlockWithContext(ctx context.Context, o *types.Object, pairs ...types.Pair) (bi *types.BlockIterator, err error) {
	defer func() {
		err =
			s.formatError("list_block", err)
	}()
	if !o.Mode.IsBlock() {
		err = services.ObjectModeInvalidError{Expected: types.ModeBlock, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.ListBlock...)
	var opt pairStorageListBlock

	opt, err = s.parsePairStorageListBlock(pairs)
	if err != nil {
		return
	}
	return s.listBlock(ctx, o, opt)
}
func (s *Storage) ListMultipart(o *types.Object, pairs ...types.Pair) (pi *types.PartIterator, err error) {
	ctx := context.Background()
	return s.ListMultipartWithContext(ctx, o, pairs...)
}
func (s *Storage) ListMultipartWithContext(ctx context.Context, o *types.Object, pairs ...types.Pair) (pi *types.PartIterator, err error) {
	defer func() {
		err =
			s.formatError("list_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: types.ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.ListMultipart...)
	var opt pairStorageListMultipart

	opt, err = s.parsePairStorageListMultipart(pairs)
	if err != nil {
		return
	}
	return s.listMultipart(ctx, o, opt)
}
func (s *Storage) Metadata(pairs ...types.Pair) (meta *types.StorageMeta) {
	pairs = append(pairs, s.defaultPairs.Metadata...)
	var opt pairStorageMetadata

	// Ignore error while handling local functions.
	opt, _ = s.parsePairStorageMetadata(pairs)
	return s.metadata(opt)
}
func (s *Storage) Move(src string, dst string, pairs ...types.Pair) (err error) {
	ctx := context.Background()
	return s.MoveWithContext(ctx, src, dst, pairs...)
}
func (s *Storage) MoveWithContext(ctx context.Context, src string, dst string, pairs ...types.Pair) (err error) {
	defer func() {
		err =
			s.formatError("move", err, src, dst)
	}()

	pairs = append(pairs, s.defaultPairs.Move...)
	var opt pairStorageMove

	opt, err = s.parsePairStorageMove(pairs)
	if err != nil {
		return
	}
	return s.move(ctx, strings.ReplaceAll(src, "\\", "/"), strings.ReplaceAll(dst, "\\", "/"), opt)
}
func (s *Storage) QuerySignHTTPCompleteMultipart(o *types.Object, parts []*types.Part, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPCompleteMultipartWithContext(ctx, o, parts, expire, pairs...)
}
func (s *Storage) QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *types.Object, parts []*types.Part, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_complete_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPCompleteMultipart...)
	var opt pairStorageQuerySignHTTPCompleteMultipart

	opt, err = s.parsePairStorageQuerySignHTTPCompleteMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPCompleteMultipart(ctx, o, parts, expire, opt)
}
func (s *Storage) QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPCreateMultipartWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_create_multipart", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPCreateMultipart...)
	var opt pairStorageQuerySignHTTPCreateMultipart

	opt, err = s.parsePairStorageQuerySignHTTPCreateMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPCreateMultipart(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPDelete(path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPDeleteWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPDelete...)
	var opt pairStorageQuerySignHTTPDelete

	opt, err = s.parsePairStorageQuerySignHTTPDelete(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPDelete(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPListMultipart(o *types.Object, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPListMultipartWithContext(ctx, o, expire, pairs...)
}
func (s *Storage) QuerySignHTTPListMultipartWithContext(ctx context.Context, o *types.Object, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_list_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPListMultipart...)
	var opt pairStorageQuerySignHTTPListMultipart

	opt, err = s.parsePairStorageQuerySignHTTPListMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPListMultipart(ctx, o, expire, opt)
}
func (s *Storage) QuerySignHTTPRead(path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPReadWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPRead...)
	var opt pairStorageQuerySignHTTPRead

	opt, err = s.parsePairStorageQuerySignHTTPRead(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPRead(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPWriteWithContext(ctx, path, size, expire, pairs...)
}
func (s *Storage) QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPWrite...)
	var opt pairStorageQuerySignHTTPWrite

	opt, err = s.parsePairStorageQuerySignHTTPWrite(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPWrite(ctx, strings.ReplaceAll(path, "\\", "/"), size, expire, opt)
}
func (s *Storage) QuerySignHTTPWriteMultipart(o *types.Object, size int64, index int, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPWriteMultipartWithContext(ctx, o, size, index, expire, pairs...)
}
func (s *Storage) QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *types.Object, size int64, index int, expire time.Duration, pairs ...types.Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_write_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPWriteMultipart...)
	var opt pairStorageQuerySignHTTPWriteMultipart

	opt, err = s.parsePairStorageQuerySignHTTPWriteMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPWriteMultipart(ctx, o, size, index, expire, opt)
}
func (s *Storage) Read(path string, w io.Writer, pairs ...types.Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...types.Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Read...)
	var opt pairStorageRead

	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}
	return s.read(ctx, strings.ReplaceAll(path, "\\", "/"), w, opt)
}
func (s *Storage) Stat(path string, pairs ...types.Pair) (o *types.Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...types.Pair) (o *types.Object, err error) {
	defer func() {
		err =
			s.formatError("stat", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Stat...)
	var opt pairStorageStat

	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}
	return s.stat(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) Write(path string, r io.Reader, size int64, pairs ...types.Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, size, pairs...)
}
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...types.Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Write...)
	var opt pairStorageWrite

	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}
	return s.write(ctx, strings.ReplaceAll(path, "\\", "/"), r, size, opt)
}
func (s *Storage) WriteAppend(o *types.Object, r io.Reader, size int64, pairs ...types.Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteAppendWithContext(ctx, o, r, size, pairs...)
}
func (s *Storage) WriteAppendWithContext(ctx context.Context, o *types.Object, r io.Reader, size int64, pairs ...types.Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("write_append", err)
	}()
	if !o.Mode.IsAppend() {
		err = services.ObjectModeInvalidError{Expected: types.ModeAppend, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.WriteAppend...)
	var opt pairStorageWriteAppend

	opt, err = s.parsePairStorageWriteAppend(pairs)
	if err != nil {
		return
	}
	return s.writeAppend(ctx, o, r, size, opt)
}
func (s *Storage) WriteBlock(o *types.Object, r io.Reader, size int64, bid string, pairs ...types.Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteBlockWithContext(ctx, o, r, size, bid, pairs...)
}
func (s *Storage) WriteBlockWithContext(ctx context.Context, o *types.Object, r io.Reader, size int64, bid string, pairs ...types.Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("write_block", err, bid)
	}()
	if !o.Mode.IsBlock() {
		err = services.ObjectModeInvalidError{Expected: types.ModeBlock, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.WriteBlock...)
	var opt pairStorageWriteBlock

	opt, err = s.parsePairStorageWriteBlock(pairs)
	if err != nil {
		return
	}
	return s.writeBlock(ctx, o, r, size, bid, opt)
}
func (s *Storage) WriteMultipart(o *types.Object, r io.Reader, size int64, index int, pairs ...types.Pair) (n int64, part *types.Part, err error) {
	ctx := context.Background()
	return s.WriteMultipartWithContext(ctx, o, r, size, index, pairs...)
}
func (s *Storage) WriteMultipartWithContext(ctx context.Context, o *types.Object, r io.Reader, size int64, index int, pairs ...types.Pair) (n int64, part *types.Part, err error) {
	defer func() {
		err =
			s.formatError("write_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: types.ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.WriteMultipart...)
	var opt pairStorageWriteMultipart

	opt, err = s.parsePairStorageWriteMultipart(pairs)
	if err != nil {
		return
	}
	return s.writeMultipart(ctx, o, r, size, index, opt)
}
func (s *Storage) WritePage(o *types.Object, r io.Reader, size int64, offset int64, pairs ...types.Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WritePageWithContext(ctx, o, r, size, offset, pairs...)
}
func (s *Storage) WritePageWithContext(ctx context.Context, o *types.Object, r io.Reader, size int64, offset int64, pairs ...types.Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("write_page", err)
	}()
	if !o.Mode.IsPage() {
		err = services.ObjectModeInvalidError{Expected: types.ModePage, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.WritePage...)
	var opt pairStorageWritePage

	opt, err = s.parsePairStorageWritePage(pairs)
	if err != nil {
		return
	}
	return s.writePage(ctx, o, r, size, offset, opt)
}
func init() {
	services.RegisterServicer(Type, NewServicer)
	services.RegisterStorager(Type, NewStorager)
	services.RegisterSchema(Type, pairMap)
}
