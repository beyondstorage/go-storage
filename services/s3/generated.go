// Code generated by go generate via cmd/definitions; DO NOT EDIT.
package s3

import (
	"context"
	"io"
	"net/http"
	"strings"
	"time"

	. "go.beyondstorage.io/v5/pairs"
	"go.beyondstorage.io/v5/pkg/httpclient"
	"go.beyondstorage.io/v5/services"
	. "go.beyondstorage.io/v5/types"
)

var (
	_ Storager
	_ services.ServiceError
	_ httpclient.Options
	_ time.Duration
	_ http.Request
	_ Error
)

// Type is the type for s3
const Type = "s3"

// ObjectSystemMetadata stores system metadata for object.
type ObjectSystemMetadata struct {
	ServerSideEncryption                  string
	ServerSideEncryptionAwsKmsKeyID       string
	ServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionContext           string
	ServerSideEncryptionCustomerAlgorithm string
	ServerSideEncryptionCustomerKeyMd5    string
	StorageClass                          string
}

// GetObjectSystemMetadata will get ObjectSystemMetadata from Object.
//
// - This function should not be called by service implementer.
// - The returning ObjectServiceMetadata is read only and should not be modified.
func GetObjectSystemMetadata(o *Object) ObjectSystemMetadata {
	sm, ok := o.GetSystemMetadata()
	if ok {
		return sm.(ObjectSystemMetadata)
	}
	return ObjectSystemMetadata{}
}

// setObjectSystemMetadata will set ObjectSystemMetadata into Object.
//
// - This function should only be called once, please make sure all data has been written before set.
func setObjectSystemMetadata(o *Object, sm ObjectSystemMetadata) {
	o.SetSystemMetadata(sm)
}

// StorageSystemMetadata stores system metadata for object.
type StorageSystemMetadata struct {
	ServerSideEncryption                  string
	ServerSideEncryptionAwsKmsKeyID       string
	ServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionContext           string
	ServerSideEncryptionCustomerAlgorithm string
	ServerSideEncryptionCustomerKeyMd5    string
	StorageClass                          string
}

// GetStorageSystemMetadata will get StorageSystemMetadata from Storage.
//
// - This function should not be called by service implementer.
// - The returning StorageServiceMetadata is read only and should not be modified.
func GetStorageSystemMetadata(s *StorageMeta) StorageSystemMetadata {
	sm, ok := s.GetSystemMetadata()
	if ok {
		return sm.(StorageSystemMetadata)
	}
	return StorageSystemMetadata{}
}

// setStorageSystemMetadata will set StorageSystemMetadata into Storage.
//
// - This function should only be called once, please make sure all data has been written before set.
func setStorageSystemMetadata(s *StorageMeta, sm StorageSystemMetadata) {
	s.SetSystemMetadata(sm)
}

// WithDefaultServicePairs will apply default_service_pairs value to Options.
func WithDefaultServicePairs(v DefaultServicePairs) Pair {
	return Pair{Key: "default_service_pairs", Value: v}
}

// WithDefaultStorageClass will apply default_storage_class value to Options.
func WithDefaultStorageClass(v string) Pair {
	return Pair{Key: "default_storage_class", Value: v}
}

// WithDefaultStoragePairs will apply default_storage_pairs value to Options.
func WithDefaultStoragePairs(v DefaultStoragePairs) Pair {
	return Pair{Key: "default_storage_pairs", Value: v}
}

// WithDisable100Continue will apply disable_100_continue value to Options.
//
// set this to `true` to disable the SDK adding the `Expect: 100-Continue` header to PUT requests over
// 2MB of content
func WithDisable100Continue() Pair {
	return Pair{Key: "disable_100_continue", Value: true}
}

// WithEnableVirtualDir will apply enable_virtual_dir value to Options.
//
// virtual_dir feature is designed for a service that doesn't have native dir support but wants to
// provide simulated operations.
//
// - If this feature is disabled (the default behavior), the service will behave like it doesn't have
// any dir support.
// - If this feature is enabled, the service will support simulated dir behavior in create_dir, create,
// list, delete, and so on.
//
// This feature was introduced in GSP-109.
func WithEnableVirtualDir() Pair {
	return Pair{Key: "enable_virtual_dir", Value: true}
}

// WithEnableVirtualLink will apply enable_virtual_link value to Options.
//
// virtual_link feature is designed for a service that doesn't have native support for link.
//
// - If this feature is enabled, the service will run compatible mode: create link via native methods,
// but allow read link from old-style link object.
// - If this feature is not enabled, the service will run in native as other service.
//
// This feature was introduced in GSP-86.
func WithEnableVirtualLink() Pair {
	return Pair{Key: "enable_virtual_link", Value: true}
}

// WithExceptedBucketOwner will apply excepted_bucket_owner value to Options.
//
// the account ID of the excepted bucket owner
func WithExceptedBucketOwner(v string) Pair {
	return Pair{Key: "excepted_bucket_owner", Value: v}
}

// WithForcePathStyle will apply force_path_style value to Options.
//
// see http://docs.aws.amazon.com/AmazonS3/latest/dev/VirtualHosting.html for Amazon S3:
// Virtual Hosting of Buckets
func WithForcePathStyle() Pair {
	return Pair{Key: "force_path_style", Value: true}
}

// WithServerSideEncryption will apply server_side_encryption value to Options.
//
// the server-side encryption algorithm used when storing this object in Amazon
func WithServerSideEncryption(v string) Pair {
	return Pair{Key: "server_side_encryption", Value: v}
}

// WithServerSideEncryptionAwsKmsKeyID will apply server_side_encryption_aws_kms_key_id
// value to Options.
//
// specifies the AWS KMS key ID to use for object encryption
func WithServerSideEncryptionAwsKmsKeyID(v string) Pair {
	return Pair{Key: "server_side_encryption_aws_kms_key_id", Value: v}
}

// WithServerSideEncryptionBucketKeyEnabled will apply server_side_encryption_bucket_key_enabled
// value to Options.
//
// specifies whether Amazon S3 should use an S3 Bucket Key for object encryption with server-side
// encryption using AWS KMS (SSE-KMS)
func WithServerSideEncryptionBucketKeyEnabled() Pair {
	return Pair{Key: "server_side_encryption_bucket_key_enabled", Value: true}
}

// WithServerSideEncryptionContext will apply server_side_encryption_context value to Options.
//
// specifies the AWS KMS Encryption Context to use for object encryption. The value of this header
// is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
func WithServerSideEncryptionContext(v string) Pair {
	return Pair{Key: "server_side_encryption_context", Value: v}
}

// WithServerSideEncryptionCustomerAlgorithm will apply server_side_encryption_customer_algorithm
// value to Options.
//
// specifies the algorithm to use to when encrypting the object. The header value must be `AES256`.
func WithServerSideEncryptionCustomerAlgorithm(v string) Pair {
	return Pair{Key: "server_side_encryption_customer_algorithm", Value: v}
}

// WithServerSideEncryptionCustomerKey will apply server_side_encryption_customer_key value
// to Options.
//
// specifies the customer-provided encryption key for Amazon S3 to use to encrypt/decrypt the source
// object. It must be 32-byte AES-256 key.
func WithServerSideEncryptionCustomerKey(v []byte) Pair {
	return Pair{Key: "server_side_encryption_customer_key", Value: v}
}

// WithServiceFeatures will apply service_features value to Options.
func WithServiceFeatures(v ServiceFeatures) Pair {
	return Pair{Key: "service_features", Value: v}
}

// WithStorageClass will apply storage_class value to Options.
func WithStorageClass(v string) Pair {
	return Pair{Key: "storage_class", Value: v}
}

// WithStorageFeatures will apply storage_features value to Options.
func WithStorageFeatures(v StorageFeatures) Pair {
	return Pair{Key: "storage_features", Value: v}
}

// WithUseAccelerate will apply use_accelerate value to Options.
//
// set this to `true` to enable S3 Accelerate feature
func WithUseAccelerate() Pair {
	return Pair{Key: "use_accelerate", Value: true}
}

// WithUseArnRegion will apply use_arn_region value to Options.
//
// set this to `true` to have the S3 service client to use the region specified in the ARN, when an ARN
// is provided as an argument to a bucket parameter
func WithUseArnRegion() Pair {
	return Pair{Key: "use_arn_region", Value: true}
}

var pairMap = map[string]string{"content_md5": "string", "content_type": "string", "context": "context.Context", "continuation_token": "string", "credential": "string", "default_content_type": "string", "default_io_callback": "func([]byte)", "default_service_pairs": "DefaultServicePairs", "default_storage_class": "string", "default_storage_pairs": "DefaultStoragePairs", "disable_100_continue": "bool", "enable_virtual_dir": "bool", "enable_virtual_link": "bool", "endpoint": "string", "excepted_bucket_owner": "string", "expire": "time.Duration", "force_path_style": "bool", "http_client_options": "*httpclient.Options", "interceptor": "Interceptor", "io_callback": "func([]byte)", "list_mode": "ListMode", "location": "string", "multipart_id": "string", "name": "string", "object_mode": "ObjectMode", "offset": "int64", "server_side_encryption": "string", "server_side_encryption_aws_kms_key_id": "string", "server_side_encryption_bucket_key_enabled": "bool", "server_side_encryption_context": "string", "server_side_encryption_customer_algorithm": "string", "server_side_encryption_customer_key": "[]byte", "service_features": "ServiceFeatures", "size": "int64", "storage_class": "string", "storage_features": "StorageFeatures", "use_accelerate": "bool", "use_arn_region": "bool", "work_dir": "string"}
var _ Servicer = &Service{}

type ServiceFeatures struct {
}

// pairServiceNew is the parsed struct
type pairServiceNew struct {
	pairs []Pair

	// Required pairs
	HasCredential bool
	Credential    string
	// Optional pairs
	HasDefaultServicePairs bool
	DefaultServicePairs    DefaultServicePairs
	HasEndpoint            bool
	Endpoint               string
	HasForcePathStyle      bool
	ForcePathStyle         bool
	HasHTTPClientOptions   bool
	HTTPClientOptions      *httpclient.Options
	HasServiceFeatures     bool
	ServiceFeatures        ServiceFeatures
	HasUseAccelerate       bool
	UseAccelerate          bool
	HasUseArnRegion        bool
	UseArnRegion           bool
	// Enable features
}

// parsePairServiceNew will parse Pair slice into *pairServiceNew
func parsePairServiceNew(opts []Pair) (pairServiceNew, error) {
	result :=
		pairServiceNew{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "credential":
			if result.HasCredential {
				continue
			}
			result.HasCredential = true
			result.Credential = v.Value.(string)
		case "default_service_pairs":
			if result.HasDefaultServicePairs {
				continue
			}
			result.HasDefaultServicePairs = true
			result.DefaultServicePairs = v.Value.(DefaultServicePairs)
		case "endpoint":
			if result.HasEndpoint {
				continue
			}
			result.HasEndpoint = true
			result.Endpoint = v.Value.(string)
		case "force_path_style":
			if result.HasForcePathStyle {
				continue
			}
			result.HasForcePathStyle = true
			result.ForcePathStyle = v.Value.(bool)
		case "http_client_options":
			if result.HasHTTPClientOptions {
				continue
			}
			result.HasHTTPClientOptions = true
			result.HTTPClientOptions = v.Value.(*httpclient.Options)
		case "service_features":
			if result.HasServiceFeatures {
				continue
			}
			result.HasServiceFeatures = true
			result.ServiceFeatures = v.Value.(ServiceFeatures)
		case "use_accelerate":
			if result.HasUseAccelerate {
				continue
			}
			result.HasUseAccelerate = true
			result.UseAccelerate = v.Value.(bool)
		case "use_arn_region":
			if result.HasUseArnRegion {
				continue
			}
			result.HasUseArnRegion = true
			result.UseArnRegion = v.Value.(bool)
		}
	}
	// Enable features

	// Default pairs

	if !result.HasCredential {
		return pairServiceNew{}, services.PairRequiredError{Keys: []string{"credential"}}
	}
	return result, nil
}

// DefaultServicePairs is default pairs for specific action
type DefaultServicePairs struct {
	Create []Pair
	Delete []Pair
	Get    []Pair
	List   []Pair
}
type pairServiceCreate struct {
	pairs []Pair
	// Required pairs
	HasLocation bool
	Location    string
	// Optional pairs
}

func (s *Service) parsePairServiceCreate(opts []Pair) (pairServiceCreate, error) {
	result :=
		pairServiceCreate{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceCreate{}, services.PairUnsupportedError{Pair: v}
		}
	}
	if !result.HasLocation {
		return pairServiceCreate{}, services.PairRequiredError{Keys: []string{"location"}}
	}
	return result, nil
}

type pairServiceDelete struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasLocation            bool
	Location               string
}

func (s *Service) parsePairServiceDelete(opts []Pair) (pairServiceDelete, error) {
	result :=
		pairServiceDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairServiceGet struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasLocation bool
	Location    string
}

func (s *Service) parsePairServiceGet(opts []Pair) (pairServiceGet, error) {
	result :=
		pairServiceGet{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		default:
			return pairServiceGet{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairServiceList struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Service) parsePairServiceList(opts []Pair) (pairServiceList, error) {
	result :=
		pairServiceList{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairServiceList{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}
func (s *Service) Create(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.CreateWithContext(ctx, name, pairs...)
}
func (s *Service) CreateWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	defer func() {
		err =
			s.formatError("create", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairServiceCreate

	opt, err = s.parsePairServiceCreate(pairs)
	if err != nil {
		return
	}
	return s.create(ctx, name, opt)
}
func (s *Service) Delete(name string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, name, pairs...)
}
func (s *Service) DeleteWithContext(ctx context.Context, name string, pairs ...Pair) (err error) {
	defer func() {
		err =
			s.formatError("delete", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairServiceDelete

	opt, err = s.parsePairServiceDelete(pairs)
	if err != nil {
		return
	}
	return s.delete(ctx, name, opt)
}
func (s *Service) Get(name string, pairs ...Pair) (store Storager, err error) {
	ctx := context.Background()
	return s.GetWithContext(ctx, name, pairs...)
}
func (s *Service) GetWithContext(ctx context.Context, name string, pairs ...Pair) (store Storager, err error) {
	defer func() {
		err =
			s.formatError("get", err, name)
	}()

	pairs = append(pairs, s.defaultPairs.Get...)
	var opt pairServiceGet

	opt, err = s.parsePairServiceGet(pairs)
	if err != nil {
		return
	}
	return s.get(ctx, name, opt)
}
func (s *Service) List(pairs ...Pair) (sti *StoragerIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, pairs...)
}
func (s *Service) ListWithContext(ctx context.Context, pairs ...Pair) (sti *StoragerIterator, err error) {
	defer func() {
		err =
			s.formatError("list", err, "")
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairServiceList

	opt, err = s.parsePairServiceList(pairs)
	if err != nil {
		return
	}
	return s.list(ctx, opt)
}

var (
	_ Direr               = &Storage{}
	_ Linker              = &Storage{}
	_ MultipartHTTPSigner = &Storage{}
	_ Multiparter         = &Storage{}
	_ StorageHTTPSigner   = &Storage{}
	_ Storager            = &Storage{}
)

type StorageFeatures struct { // virtual_dir feature is designed for a service that doesn't have native dir support but wants to
	// provide simulated operations.
	//
	// - If this feature is disabled (the default behavior), the service will behave like it doesn't have
	// any dir support.
	// - If this feature is enabled, the service will support simulated dir behavior in create_dir, create,
	// list, delete, and so on.
	//
	// This feature was introduced in GSP-109.
	VirtualDir bool
	// virtual_link feature is designed for a service that doesn't have native support for link.
	//
	// - If this feature is enabled, the service will run compatible mode: create link via native methods,
	// but allow read link from old-style link object.
	// - If this feature is not enabled, the service will run in native as other service.
	//
	// This feature was introduced in GSP-86.
	VirtualLink bool
}

// pairStorageNew is the parsed struct
type pairStorageNew struct {
	pairs []Pair

	// Required pairs
	HasLocation bool
	Location    string
	HasName     bool
	Name        string
	// Optional pairs
	HasDefaultContentType  bool
	DefaultContentType     string
	HasDefaultIoCallback   bool
	DefaultIoCallback      func([]byte)
	HasDefaultStorageClass bool
	DefaultStorageClass    string
	HasDefaultStoragePairs bool
	DefaultStoragePairs    DefaultStoragePairs
	HasStorageFeatures     bool
	StorageFeatures        StorageFeatures
	HasWorkDir             bool
	WorkDir                string
	// Enable features
	hasEnableVirtualDir  bool
	EnableVirtualDir     bool
	hasEnableVirtualLink bool
	EnableVirtualLink    bool
}

// parsePairStorageNew will parse Pair slice into *pairStorageNew
func parsePairStorageNew(opts []Pair) (pairStorageNew, error) {
	result :=
		pairStorageNew{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "location":
			if result.HasLocation {
				continue
			}
			result.HasLocation = true
			result.Location = v.Value.(string)
		case "name":
			if result.HasName {
				continue
			}
			result.HasName = true
			result.Name = v.Value.(string)
		case "default_content_type":
			if result.HasDefaultContentType {
				continue
			}
			result.HasDefaultContentType = true
			result.DefaultContentType = v.Value.(string)
		case "default_io_callback":
			if result.HasDefaultIoCallback {
				continue
			}
			result.HasDefaultIoCallback = true
			result.DefaultIoCallback = v.Value.(func([]byte))
		case "default_storage_class":
			if result.HasDefaultStorageClass {
				continue
			}
			result.HasDefaultStorageClass = true
			result.DefaultStorageClass = v.Value.(string)
		case "default_storage_pairs":
			if result.HasDefaultStoragePairs {
				continue
			}
			result.HasDefaultStoragePairs = true
			result.DefaultStoragePairs = v.Value.(DefaultStoragePairs)
		case "storage_features":
			if result.HasStorageFeatures {
				continue
			}
			result.HasStorageFeatures = true
			result.StorageFeatures = v.Value.(StorageFeatures)
		case "work_dir":
			if result.HasWorkDir {
				continue
			}
			result.HasWorkDir = true
			result.WorkDir = v.Value.(string)
		case "enable_virtual_dir":
			if result.hasEnableVirtualDir {
				continue
			}
			result.hasEnableVirtualDir = true
			result.EnableVirtualDir = true
		case "enable_virtual_link":
			if result.hasEnableVirtualLink {
				continue
			}
			result.hasEnableVirtualLink = true
			result.EnableVirtualLink = true
		}
	}
	// Enable features
	if result.hasEnableVirtualDir {
		result.HasStorageFeatures = true
		result.StorageFeatures.VirtualDir = true
	}
	if result.hasEnableVirtualLink {
		result.HasStorageFeatures = true
		result.StorageFeatures.VirtualLink = true
	}
	// Default pairs
	if result.HasDefaultContentType {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.QuerySignHTTPWrite = append(result.DefaultStoragePairs.QuerySignHTTPWrite, WithContentType(result.DefaultContentType))
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithContentType(result.DefaultContentType))
	}
	if result.HasDefaultIoCallback {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.Read = append(result.DefaultStoragePairs.Read, WithIoCallback(result.DefaultIoCallback))
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithIoCallback(result.DefaultIoCallback))
		result.DefaultStoragePairs.WriteMultipart = append(result.DefaultStoragePairs.WriteMultipart, WithIoCallback(result.DefaultIoCallback))
	}
	if result.HasDefaultStorageClass {
		result.HasDefaultStoragePairs = true
		result.DefaultStoragePairs.CreateDir = append(result.DefaultStoragePairs.CreateDir, WithStorageClass(result.DefaultStorageClass))
		result.DefaultStoragePairs.QuerySignHTTPWrite = append(result.DefaultStoragePairs.QuerySignHTTPWrite, WithStorageClass(result.DefaultStorageClass))
		result.DefaultStoragePairs.Write = append(result.DefaultStoragePairs.Write, WithStorageClass(result.DefaultStorageClass))
	}
	if !result.HasLocation {
		return pairStorageNew{}, services.PairRequiredError{Keys: []string{"location"}}
	}
	if !result.HasName {
		return pairStorageNew{}, services.PairRequiredError{Keys: []string{"name"}}
	}
	return result, nil
}

// DefaultStoragePairs is default pairs for specific action
type DefaultStoragePairs struct {
	CompleteMultipart              []Pair
	Create                         []Pair
	CreateDir                      []Pair
	CreateLink                     []Pair
	CreateMultipart                []Pair
	Delete                         []Pair
	List                           []Pair
	ListMultipart                  []Pair
	Metadata                       []Pair
	QuerySignHTTPCompleteMultipart []Pair
	QuerySignHTTPCreateMultipart   []Pair
	QuerySignHTTPDelete            []Pair
	QuerySignHTTPListMultipart     []Pair
	QuerySignHTTPRead              []Pair
	QuerySignHTTPWrite             []Pair
	QuerySignHTTPWriteMultipart    []Pair
	Read                           []Pair
	Stat                           []Pair
	Write                          []Pair
	WriteMultipart                 []Pair
}
type pairStorageCompleteMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
}

func (s *Storage) parsePairStorageCompleteMultipart(opts []Pair) (pairStorageCompleteMultipart, error) {
	result :=
		pairStorageCompleteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		default:
			return pairStorageCompleteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreate struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasMultipartID bool
	MultipartID    string
	HasObjectMode  bool
	ObjectMode     ObjectMode
}

func (s *Storage) parsePairStorageCreate(opts []Pair) (pairStorageCreate, error) {
	result :=
		pairStorageCreate{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
		default:
			return pairStorageCreate{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateDir struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasStorageClass        bool
	StorageClass           string
}

func (s *Storage) parsePairStorageCreateDir(opts []Pair) (pairStorageCreateDir, error) {
	result :=
		pairStorageCreateDir{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "storage_class":
			if result.HasStorageClass {
				continue
			}
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		default:
			return pairStorageCreateDir{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateLink struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageCreateLink(opts []Pair) (pairStorageCreateLink, error) {
	result :=
		pairStorageCreateLink{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageCreateLink{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageCreateMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasServerSideEncryption                  bool
	ServerSideEncryption                     string
	HasServerSideEncryptionAwsKmsKeyID       bool
	ServerSideEncryptionAwsKmsKeyID          string
	HasServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionBucketKeyEnabled     bool
	HasServerSideEncryptionContext           bool
	ServerSideEncryptionContext              string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
}

func (s *Storage) parsePairStorageCreateMultipart(opts []Pair) (pairStorageCreateMultipart, error) {
	result :=
		pairStorageCreateMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "server_side_encryption":
			if result.HasServerSideEncryption {
				continue
			}
			result.HasServerSideEncryption = true
			result.ServerSideEncryption = v.Value.(string)
		case "server_side_encryption_aws_kms_key_id":
			if result.HasServerSideEncryptionAwsKmsKeyID {
				continue
			}
			result.HasServerSideEncryptionAwsKmsKeyID = true
			result.ServerSideEncryptionAwsKmsKeyID = v.Value.(string)
		case "server_side_encryption_bucket_key_enabled":
			if result.HasServerSideEncryptionBucketKeyEnabled {
				continue
			}
			result.HasServerSideEncryptionBucketKeyEnabled = true
			result.ServerSideEncryptionBucketKeyEnabled = v.Value.(bool)
		case "server_side_encryption_context":
			if result.HasServerSideEncryptionContext {
				continue
			}
			result.HasServerSideEncryptionContext = true
			result.ServerSideEncryptionContext = v.Value.(string)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		default:
			return pairStorageCreateMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageDelete struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasMultipartID         bool
	MultipartID            string
	HasObjectMode          bool
	ObjectMode             ObjectMode
}

func (s *Storage) parsePairStorageDelete(opts []Pair) (pairStorageDelete, error) {
	result :=
		pairStorageDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
		default:
			return pairStorageDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageList struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasListMode            bool
	ListMode               ListMode
}

func (s *Storage) parsePairStorageList(opts []Pair) (pairStorageList, error) {
	result :=
		pairStorageList{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "list_mode":
			if result.HasListMode {
				continue
			}
			result.HasListMode = true
			result.ListMode = v.Value.(ListMode)
		default:
			return pairStorageList{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageListMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
}

func (s *Storage) parsePairStorageListMultipart(opts []Pair) (pairStorageListMultipart, error) {
	result :=
		pairStorageListMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		default:
			return pairStorageListMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageMetadata struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageMetadata(opts []Pair) (pairStorageMetadata, error) {
	result :=
		pairStorageMetadata{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageMetadata{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPCompleteMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPCompleteMultipart(opts []Pair) (pairStorageQuerySignHTTPCompleteMultipart, error) {
	result :=
		pairStorageQuerySignHTTPCompleteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageQuerySignHTTPCompleteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPCreateMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPCreateMultipart(opts []Pair) (pairStorageQuerySignHTTPCreateMultipart, error) {
	result :=
		pairStorageQuerySignHTTPCreateMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageQuerySignHTTPCreateMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPDelete struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner bool
	ExceptedBucketOwner    string
	HasMultipartID         bool
	MultipartID            string
	HasObjectMode          bool
	ObjectMode             ObjectMode
}

func (s *Storage) parsePairStorageQuerySignHTTPDelete(opts []Pair) (pairStorageQuerySignHTTPDelete, error) {
	result :=
		pairStorageQuerySignHTTPDelete{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
		default:
			return pairStorageQuerySignHTTPDelete{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPListMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPListMultipart(opts []Pair) (pairStorageQuerySignHTTPListMultipart, error) {
	result :=
		pairStorageQuerySignHTTPListMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageQuerySignHTTPListMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPRead struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasOffset                                bool
	Offset                                   int64
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasSize                                  bool
	Size                                     int64
}

func (s *Storage) parsePairStorageQuerySignHTTPRead(opts []Pair) (pairStorageQuerySignHTTPRead, error) {
	result :=
		pairStorageQuerySignHTTPRead{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case "size":
			if result.HasSize {
				continue
			}
			result.HasSize = true
			result.Size = v.Value.(int64)
		default:
			return pairStorageQuerySignHTTPRead{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPWrite struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasContentMd5                            bool
	ContentMd5                               string
	HasContentType                           bool
	ContentType                              string
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasServerSideEncryption                  bool
	ServerSideEncryption                     string
	HasServerSideEncryptionAwsKmsKeyID       bool
	ServerSideEncryptionAwsKmsKeyID          string
	HasServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionBucketKeyEnabled     bool
	HasServerSideEncryptionContext           bool
	ServerSideEncryptionContext              string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasStorageClass                          bool
	StorageClass                             string
}

func (s *Storage) parsePairStorageQuerySignHTTPWrite(opts []Pair) (pairStorageQuerySignHTTPWrite, error) {
	result :=
		pairStorageQuerySignHTTPWrite{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "content_md5":
			if result.HasContentMd5 {
				continue
			}
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
		case "content_type":
			if result.HasContentType {
				continue
			}
			result.HasContentType = true
			result.ContentType = v.Value.(string)
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "server_side_encryption":
			if result.HasServerSideEncryption {
				continue
			}
			result.HasServerSideEncryption = true
			result.ServerSideEncryption = v.Value.(string)
		case "server_side_encryption_aws_kms_key_id":
			if result.HasServerSideEncryptionAwsKmsKeyID {
				continue
			}
			result.HasServerSideEncryptionAwsKmsKeyID = true
			result.ServerSideEncryptionAwsKmsKeyID = v.Value.(string)
		case "server_side_encryption_bucket_key_enabled":
			if result.HasServerSideEncryptionBucketKeyEnabled {
				continue
			}
			result.HasServerSideEncryptionBucketKeyEnabled = true
			result.ServerSideEncryptionBucketKeyEnabled = v.Value.(bool)
		case "server_side_encryption_context":
			if result.HasServerSideEncryptionContext {
				continue
			}
			result.HasServerSideEncryptionContext = true
			result.ServerSideEncryptionContext = v.Value.(string)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case "storage_class":
			if result.HasStorageClass {
				continue
			}
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		default:
			return pairStorageQuerySignHTTPWrite{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageQuerySignHTTPWriteMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
}

func (s *Storage) parsePairStorageQuerySignHTTPWriteMultipart(opts []Pair) (pairStorageQuerySignHTTPWriteMultipart, error) {
	result :=
		pairStorageQuerySignHTTPWriteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		default:
			return pairStorageQuerySignHTTPWriteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageRead struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasIoCallback                            bool
	IoCallback                               func([]byte)
	HasOffset                                bool
	Offset                                   int64
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasSize                                  bool
	Size                                     int64
}

func (s *Storage) parsePairStorageRead(opts []Pair) (pairStorageRead, error) {
	result :=
		pairStorageRead{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "offset":
			if result.HasOffset {
				continue
			}
			result.HasOffset = true
			result.Offset = v.Value.(int64)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case "size":
			if result.HasSize {
				continue
			}
			result.HasSize = true
			result.Size = v.Value.(int64)
		default:
			return pairStorageRead{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageStat struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasMultipartID                           bool
	MultipartID                              string
	HasObjectMode                            bool
	ObjectMode                               ObjectMode
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
}

func (s *Storage) parsePairStorageStat(opts []Pair) (pairStorageStat, error) {
	result :=
		pairStorageStat{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "multipart_id":
			if result.HasMultipartID {
				continue
			}
			result.HasMultipartID = true
			result.MultipartID = v.Value.(string)
		case "object_mode":
			if result.HasObjectMode {
				continue
			}
			result.HasObjectMode = true
			result.ObjectMode = v.Value.(ObjectMode)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		default:
			return pairStorageStat{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWrite struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasContentMd5                            bool
	ContentMd5                               string
	HasContentType                           bool
	ContentType                              string
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasIoCallback                            bool
	IoCallback                               func([]byte)
	HasServerSideEncryption                  bool
	ServerSideEncryption                     string
	HasServerSideEncryptionAwsKmsKeyID       bool
	ServerSideEncryptionAwsKmsKeyID          string
	HasServerSideEncryptionBucketKeyEnabled  bool
	ServerSideEncryptionBucketKeyEnabled     bool
	HasServerSideEncryptionContext           bool
	ServerSideEncryptionContext              string
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
	HasStorageClass                          bool
	StorageClass                             string
}

func (s *Storage) parsePairStorageWrite(opts []Pair) (pairStorageWrite, error) {
	result :=
		pairStorageWrite{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "content_md5":
			if result.HasContentMd5 {
				continue
			}
			result.HasContentMd5 = true
			result.ContentMd5 = v.Value.(string)
		case "content_type":
			if result.HasContentType {
				continue
			}
			result.HasContentType = true
			result.ContentType = v.Value.(string)
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "server_side_encryption":
			if result.HasServerSideEncryption {
				continue
			}
			result.HasServerSideEncryption = true
			result.ServerSideEncryption = v.Value.(string)
		case "server_side_encryption_aws_kms_key_id":
			if result.HasServerSideEncryptionAwsKmsKeyID {
				continue
			}
			result.HasServerSideEncryptionAwsKmsKeyID = true
			result.ServerSideEncryptionAwsKmsKeyID = v.Value.(string)
		case "server_side_encryption_bucket_key_enabled":
			if result.HasServerSideEncryptionBucketKeyEnabled {
				continue
			}
			result.HasServerSideEncryptionBucketKeyEnabled = true
			result.ServerSideEncryptionBucketKeyEnabled = v.Value.(bool)
		case "server_side_encryption_context":
			if result.HasServerSideEncryptionContext {
				continue
			}
			result.HasServerSideEncryptionContext = true
			result.ServerSideEncryptionContext = v.Value.(string)
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		case "storage_class":
			if result.HasStorageClass {
				continue
			}
			result.HasStorageClass = true
			result.StorageClass = v.Value.(string)
		default:
			return pairStorageWrite{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}

type pairStorageWriteMultipart struct {
	pairs []Pair
	// Required pairs
	// Optional pairs
	HasExceptedBucketOwner                   bool
	ExceptedBucketOwner                      string
	HasIoCallback                            bool
	IoCallback                               func([]byte)
	HasServerSideEncryptionCustomerAlgorithm bool
	ServerSideEncryptionCustomerAlgorithm    string
	HasServerSideEncryptionCustomerKey       bool
	ServerSideEncryptionCustomerKey          []byte
}

func (s *Storage) parsePairStorageWriteMultipart(opts []Pair) (pairStorageWriteMultipart, error) {
	result :=
		pairStorageWriteMultipart{pairs: opts}

	for _, v := range opts {
		switch v.Key {
		case "excepted_bucket_owner":
			if result.HasExceptedBucketOwner {
				continue
			}
			result.HasExceptedBucketOwner = true
			result.ExceptedBucketOwner = v.Value.(string)
		case "io_callback":
			if result.HasIoCallback {
				continue
			}
			result.HasIoCallback = true
			result.IoCallback = v.Value.(func([]byte))
		case "server_side_encryption_customer_algorithm":
			if result.HasServerSideEncryptionCustomerAlgorithm {
				continue
			}
			result.HasServerSideEncryptionCustomerAlgorithm = true
			result.ServerSideEncryptionCustomerAlgorithm = v.Value.(string)
		case "server_side_encryption_customer_key":
			if result.HasServerSideEncryptionCustomerKey {
				continue
			}
			result.HasServerSideEncryptionCustomerKey = true
			result.ServerSideEncryptionCustomerKey = v.Value.([]byte)
		default:
			return pairStorageWriteMultipart{}, services.PairUnsupportedError{Pair: v}
		}
	}

	return result, nil
}
func (s *Storage) CompleteMultipart(o *Object, parts []*Part, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.CompleteMultipartWithContext(ctx, o, parts, pairs...)
}
func (s *Storage) CompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, pairs ...Pair) (err error) {
	defer func() {
		err =
			s.formatError("complete_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.CompleteMultipart...)
	var opt pairStorageCompleteMultipart

	opt, err = s.parsePairStorageCompleteMultipart(pairs)
	if err != nil {
		return
	}
	return s.completeMultipart(ctx, o, parts, opt)
}
func (s *Storage) Create(path string, pairs ...Pair) (o *Object) {
	pairs = append(pairs, s.defaultPairs.Create...)
	var opt pairStorageCreate

	// Ignore error while handling local functions.
	opt, _ = s.parsePairStorageCreate(pairs)
	return s.create(path, opt)
}
func (s *Storage) CreateDir(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateDirWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateDirWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err =
			s.formatError("create_dir", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateDir...)
	var opt pairStorageCreateDir

	opt, err = s.parsePairStorageCreateDir(pairs)
	if err != nil {
		return
	}
	return s.createDir(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) CreateLink(path string, target string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateLinkWithContext(ctx, path, target, pairs...)
}
func (s *Storage) CreateLinkWithContext(ctx context.Context, path string, target string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err =
			s.formatError("create_link", err, path, target)
	}()

	pairs = append(pairs, s.defaultPairs.CreateLink...)
	var opt pairStorageCreateLink

	opt, err = s.parsePairStorageCreateLink(pairs)
	if err != nil {
		return
	}
	return s.createLink(ctx, strings.ReplaceAll(path, "\\", "/"), strings.ReplaceAll(target, "\\", "/"), opt)
}
func (s *Storage) CreateMultipart(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.CreateMultipartWithContext(ctx, path, pairs...)
}
func (s *Storage) CreateMultipartWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err =
			s.formatError("create_multipart", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.CreateMultipart...)
	var opt pairStorageCreateMultipart

	opt, err = s.parsePairStorageCreateMultipart(pairs)
	if err != nil {
		return
	}
	return s.createMultipart(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) Delete(path string, pairs ...Pair) (err error) {
	ctx := context.Background()
	return s.DeleteWithContext(ctx, path, pairs...)
}
func (s *Storage) DeleteWithContext(ctx context.Context, path string, pairs ...Pair) (err error) {
	defer func() {
		err =
			s.formatError("delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Delete...)
	var opt pairStorageDelete

	opt, err = s.parsePairStorageDelete(pairs)
	if err != nil {
		return
	}
	return s.delete(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) List(path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	ctx := context.Background()
	return s.ListWithContext(ctx, path, pairs...)
}
func (s *Storage) ListWithContext(ctx context.Context, path string, pairs ...Pair) (oi *ObjectIterator, err error) {
	defer func() {
		err =
			s.formatError("list", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.List...)
	var opt pairStorageList

	opt, err = s.parsePairStorageList(pairs)
	if err != nil {
		return
	}
	return s.list(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) ListMultipart(o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	ctx := context.Background()
	return s.ListMultipartWithContext(ctx, o, pairs...)
}
func (s *Storage) ListMultipartWithContext(ctx context.Context, o *Object, pairs ...Pair) (pi *PartIterator, err error) {
	defer func() {
		err =
			s.formatError("list_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.ListMultipart...)
	var opt pairStorageListMultipart

	opt, err = s.parsePairStorageListMultipart(pairs)
	if err != nil {
		return
	}
	return s.listMultipart(ctx, o, opt)
}
func (s *Storage) Metadata(pairs ...Pair) (meta *StorageMeta) {
	pairs = append(pairs, s.defaultPairs.Metadata...)
	var opt pairStorageMetadata

	// Ignore error while handling local functions.
	opt, _ = s.parsePairStorageMetadata(pairs)
	return s.metadata(opt)
}
func (s *Storage) QuerySignHTTPCompleteMultipart(o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPCompleteMultipartWithContext(ctx, o, parts, expire, pairs...)
}
func (s *Storage) QuerySignHTTPCompleteMultipartWithContext(ctx context.Context, o *Object, parts []*Part, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_complete_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPCompleteMultipart...)
	var opt pairStorageQuerySignHTTPCompleteMultipart

	opt, err = s.parsePairStorageQuerySignHTTPCompleteMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPCompleteMultipart(ctx, o, parts, expire, opt)
}
func (s *Storage) QuerySignHTTPCreateMultipart(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPCreateMultipartWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPCreateMultipartWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_create_multipart", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPCreateMultipart...)
	var opt pairStorageQuerySignHTTPCreateMultipart

	opt, err = s.parsePairStorageQuerySignHTTPCreateMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPCreateMultipart(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPDelete(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPDeleteWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPDeleteWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_delete", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPDelete...)
	var opt pairStorageQuerySignHTTPDelete

	opt, err = s.parsePairStorageQuerySignHTTPDelete(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPDelete(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPListMultipart(o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPListMultipartWithContext(ctx, o, expire, pairs...)
}
func (s *Storage) QuerySignHTTPListMultipartWithContext(ctx context.Context, o *Object, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_list_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPListMultipart...)
	var opt pairStorageQuerySignHTTPListMultipart

	opt, err = s.parsePairStorageQuerySignHTTPListMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPListMultipart(ctx, o, expire, opt)
}
func (s *Storage) QuerySignHTTPRead(path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPReadWithContext(ctx, path, expire, pairs...)
}
func (s *Storage) QuerySignHTTPReadWithContext(ctx context.Context, path string, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPRead...)
	var opt pairStorageQuerySignHTTPRead

	opt, err = s.parsePairStorageQuerySignHTTPRead(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPRead(ctx, strings.ReplaceAll(path, "\\", "/"), expire, opt)
}
func (s *Storage) QuerySignHTTPWrite(path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPWriteWithContext(ctx, path, size, expire, pairs...)
}
func (s *Storage) QuerySignHTTPWriteWithContext(ctx context.Context, path string, size int64, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPWrite...)
	var opt pairStorageQuerySignHTTPWrite

	opt, err = s.parsePairStorageQuerySignHTTPWrite(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPWrite(ctx, strings.ReplaceAll(path, "\\", "/"), size, expire, opt)
}
func (s *Storage) QuerySignHTTPWriteMultipart(o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	ctx := context.Background()
	return s.QuerySignHTTPWriteMultipartWithContext(ctx, o, size, index, expire, pairs...)
}
func (s *Storage) QuerySignHTTPWriteMultipartWithContext(ctx context.Context, o *Object, size int64, index int, expire time.Duration, pairs ...Pair) (req *http.Request, err error) {
	defer func() {
		err =
			s.formatError("query_sign_http_write_multipart", err)
	}()

	pairs = append(pairs, s.defaultPairs.QuerySignHTTPWriteMultipart...)
	var opt pairStorageQuerySignHTTPWriteMultipart

	opt, err = s.parsePairStorageQuerySignHTTPWriteMultipart(pairs)
	if err != nil {
		return
	}
	return s.querySignHTTPWriteMultipart(ctx, o, size, index, expire, opt)
}
func (s *Storage) Read(path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.ReadWithContext(ctx, path, w, pairs...)
}
func (s *Storage) ReadWithContext(ctx context.Context, path string, w io.Writer, pairs ...Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("read", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Read...)
	var opt pairStorageRead

	opt, err = s.parsePairStorageRead(pairs)
	if err != nil {
		return
	}
	return s.read(ctx, strings.ReplaceAll(path, "\\", "/"), w, opt)
}
func (s *Storage) Stat(path string, pairs ...Pair) (o *Object, err error) {
	ctx := context.Background()
	return s.StatWithContext(ctx, path, pairs...)
}
func (s *Storage) StatWithContext(ctx context.Context, path string, pairs ...Pair) (o *Object, err error) {
	defer func() {
		err =
			s.formatError("stat", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Stat...)
	var opt pairStorageStat

	opt, err = s.parsePairStorageStat(pairs)
	if err != nil {
		return
	}
	return s.stat(ctx, strings.ReplaceAll(path, "\\", "/"), opt)
}
func (s *Storage) Write(path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	ctx := context.Background()
	return s.WriteWithContext(ctx, path, r, size, pairs...)
}
func (s *Storage) WriteWithContext(ctx context.Context, path string, r io.Reader, size int64, pairs ...Pair) (n int64, err error) {
	defer func() {
		err =
			s.formatError("write", err, path)
	}()

	pairs = append(pairs, s.defaultPairs.Write...)
	var opt pairStorageWrite

	opt, err = s.parsePairStorageWrite(pairs)
	if err != nil {
		return
	}
	return s.write(ctx, strings.ReplaceAll(path, "\\", "/"), r, size, opt)
}
func (s *Storage) WriteMultipart(o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	ctx := context.Background()
	return s.WriteMultipartWithContext(ctx, o, r, size, index, pairs...)
}
func (s *Storage) WriteMultipartWithContext(ctx context.Context, o *Object, r io.Reader, size int64, index int, pairs ...Pair) (n int64, part *Part, err error) {
	defer func() {
		err =
			s.formatError("write_multipart", err)
	}()
	if !o.Mode.IsPart() {
		err = services.ObjectModeInvalidError{Expected: ModePart, Actual: o.Mode}
		return
	}
	pairs = append(pairs, s.defaultPairs.WriteMultipart...)
	var opt pairStorageWriteMultipart

	opt, err = s.parsePairStorageWriteMultipart(pairs)
	if err != nil {
		return
	}
	return s.writeMultipart(ctx, o, r, size, index, opt)
}
func init() {
	services.RegisterServicer(Type, NewServicer)
	services.RegisterStorager(Type, NewStorager)
	services.RegisterSchema(Type, pairMap)
}
