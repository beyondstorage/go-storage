package definitions

import (
	"github.com/Xuanwo/gg"
	"github.com/Xuanwo/templateutils"
	log "github.com/sirupsen/logrus"
)

func GenerateOperation(path string) {
	f := gg.NewGroup()
	f.AddLineComment("Code generated by go generate cmd/definitions; DO NOT EDIT.")
	f.AddPackage("types")
	f.NewImport().
		AddPath("context").
		AddPath("io").
		AddPath("net/http").
		AddPath("time")

	for _, ns := range []string{NamespaceService, NamespaceStorage} {
		nsDisplayName := templateutils.ToPascal(ns) + "r"
		ops := SortOperations(GetOperations(ns))

		inter := f.NewInterface(nsDisplayName)
		inter.NewFunction("String").AddResult("", "string")
		inter.NewFunction("Features").AddResult("", templateutils.ToPascal(ns)+"Features")

		for _, op := range ops {
			pname := templateutils.ToPascal(op.Name)

			inter.AddLineComment("%s %s", pname, op.Description)
			gop := inter.NewFunction(pname)

			for _, p := range op.Params {
				gop.AddParameter(p.Name, p.Type.FullName("types"))
			}
			for _, r := range op.Results {
				gop.AddResult(r.Name, r.Type.FullName("types"))
			}

			// We need to generate XxxWithContext functions if not local.
			if !op.Local {
				inter.AddLineComment("%sWithContext %s", pname, op.Description)
				gop := inter.NewFunction(pname + "WithContext")

				// Insert context param.
				gop.AddParameter("ctx", "context.Context")
				for _, p := range op.Params {
					gop.AddParameter(p.Name, p.Type.FullName("types"))
				}
				for _, r := range op.Results {
					gop.AddResult(r.Name, r.Type.FullName("types"))
				}
			}
			// Insert an empty for different functions.
			inter.AddLine()
		}
		inter.NewFunction("mustEmbedUnimplemented" + nsDisplayName)

		stubName := "Unimplemented" + nsDisplayName
		f.AddLineComment("%s must be embedded to have forward compatible implementations.", stubName)
		f.NewStruct(stubName)

		f.NewFunction("mustEmbedUnimplemented"+nsDisplayName).
			WithReceiver("s", stubName).
			AddBody(gg.Line())
		f.NewFunction("String").
			WithReceiver("s", stubName).
			AddResult("", "string").
			AddBody(
				gg.Return(gg.Lit(stubName)))
		f.NewFunction("Features").
			WithReceiver("s", stubName).
			AddResult("fe", templateutils.ToPascal(ns)+"Features").
			AddBody(gg.Return())

		for _, op := range ops {
			pname := templateutils.ToPascal(op.Name)

			gop := f.NewFunction(pname).
				WithReceiver("s", stubName)

			for _, p := range op.Params {
				gop.AddParameter(p.Name, p.Type.FullName("types"))
			}
			for _, r := range op.Results {
				gop.AddResult(r.Name, r.Type.FullName("types"))
			}
			// If not local, we need to add and set error
			if !op.Local {
				gop.AddBody(gg.S(`err = NewOperationNotImplementedError("%s")`, op.Name))
			}
			gop.AddBody(gg.Return())

			// We need to generate XxxWithContext functions if not local.
			if !op.Local {
				gop := f.NewFunction(pname+"WithContext").
					WithReceiver("s", stubName)

				// Insert context param.
				gop.AddParameter("ctx", "context.Context")
				for _, p := range op.Params {
					gop.AddParameter(p.Name, p.Type.FullName("types"))
				}
				for _, r := range op.Results {
					gop.AddResult(r.Name, r.Type.FullName("types"))
				}
				gop.AddBody(
					gg.S(`err = NewOperationNotImplementedError("%s")`, op.Name),
					gg.Return(),
				)
			}
		}
	}

	err := f.WriteFile(path)
	if err != nil {
		log.Fatalf("generate to %s: %v", path, err)
	}
}
