package definitions

import (
	"fmt"
	"github.com/Xuanwo/gg"
	"github.com/Xuanwo/templateutils"
	log "github.com/sirupsen/logrus"
)

type genService struct {
	g    *gg.Generator
	data Metadata
}

func GenerateService(data Metadata, path string) {
	gs := genService{
		g:    gg.New(),
		data: data,
	}

	gs.generateHeader()
	gs.generateObjectSystemMetadata()
	gs.generateStorageSystemMetadata()
	gs.generateSystemPairs()
	gs.generateFactory()

	for _, nsName := range []string{NamespaceService, NamespaceStorage} {
		gs.generateNamespace(nsName)
	}

	err := gs.g.WriteFile(path)
	if err != nil {
		log.Fatalf("generate to %s: %v", path, err)
	}
}

func (gs *genService) generateHeader() {
	f := gs.g.NewGroup()

	f.AddLineComment("Code generated by go generate via cmd/definitions; DO NOT EDIT.")
	f.AddPackage(gs.data.Name)
	f.NewImport().
		AddPath("context").
		AddPath("io").
		AddPath("net/http").
		AddPath("strings").
		AddPath("time").
		AddLine().
		AddDot("go.beyondstorage.io/v5/pairs").
		AddPath("go.beyondstorage.io/v5/pkg/httpclient").
		AddPath("go.beyondstorage.io/v5/services").
		AddPath("go.beyondstorage.io/v5/types")

	f.NewVar().
		AddDecl("_", "types.Storager").
		AddDecl("_", "services.ServiceError").
		AddDecl("_", "httpclient.Options").
		AddDecl("_", "time.Duration").
		AddDecl("_", "http.Request").
		AddDecl("_", "Error")

	f.AddLineComment("Type is the type for %s", gs.data.Name)
	f.NewConst().AddField("Type", gg.Lit(gs.data.Name).String())
}
func (gs *genService) generateObjectSystemMetadata() {
	f := gs.g.NewGroup()
	data := gs.data

	f.AddLineComment("ObjectSystemMetadata stores system metadata for object.")
	osm := f.NewStruct("ObjectSystemMetadata")
	for _, info := range SortInfos(data.Infos) {
		if info.Namespace != NamespaceObject {
			continue
		}
		pname := templateutils.ToPascal(info.Name)
		// FIXME: we will support comment on field later.
		osm.AddField(pname, info.Type.FullName(data.Name))
	}

	f.AddLineComment(`
GetObjectSystemMetadata will get ObjectSystemMetadata from Object.

- This function should not be called by service implementer.
- The returning ObjectServiceMetadata is read only and should not be modified.
`)
	gosmfn := f.NewFunction("GetObjectSystemMetadata")
	gosmfn.AddParameter("o", "*types.Object").
		AddResult("", "ObjectSystemMetadata")
	gosmfn.AddBody(
		gg.S("sm, ok := o.GetSystemMetadata()"),
		gg.If(gg.S("ok")).
			AddBody(gg.Return("sm.(ObjectSystemMetadata)")),
		gg.Return(gg.Value("ObjectSystemMetadata")),
	)

	f.AddLineComment(`
setObjectSystemMetadata will set ObjectSystemMetadata into Object.

- This function should only be called once, please make sure all data has been written before set.
`)

	sosmfn := f.NewFunction("setObjectSystemMetadata")
	sosmfn.AddParameter("o", "*types.Object").
		AddParameter("sm", "ObjectSystemMetadata")
	sosmfn.AddBody(
		gg.S("o.SetSystemMetadata(sm)"),
	)
}
func (gs *genService) generateStorageSystemMetadata() {
	f := gs.g.NewGroup()
	data := gs.data

	// Generate storage system metadata.
	f.AddLineComment("StorageSystemMetadata stores system metadata for object.")
	ssm := f.NewStruct("StorageSystemMetadata")
	for _, info := range SortInfos(data.Infos) {
		if info.Namespace != NamespaceStorage {
			continue
		}
		pname := templateutils.ToPascal(info.Name)
		// FIXME: we will support comment on field later.
		ssm.AddField(pname, info.Type.FullName(data.Name))
	}

	f.AddLineComment(`
GetStorageSystemMetadata will get StorageSystemMetadata from Storage.

- This function should not be called by service implementer.
- The returning StorageServiceMetadata is read only and should not be modified.
`)
	gssmfn := f.NewFunction("GetStorageSystemMetadata")
	gssmfn.AddParameter("s", "*types.StorageMeta").
		AddResult("", "StorageSystemMetadata")
	gssmfn.AddBody(
		gg.S("sm, ok := s.GetSystemMetadata()"),
		gg.If(gg.S("ok")).
			AddBody(gg.Return("sm.(StorageSystemMetadata)")),
		gg.Return(gg.Value("StorageSystemMetadata")),
	)

	f.AddLineComment(`setStorageSystemMetadata will set StorageSystemMetadata into Storage.

- This function should only be called once, please make sure all data has been written before set.`)
	sssmfn := f.NewFunction("setStorageSystemMetadata")
	sssmfn.AddParameter("s", "*types.StorageMeta").
		AddParameter("sm", "StorageSystemMetadata")
	sssmfn.AddBody(
		gg.S("s.SetSystemMetadata(sm)"),
	)
}
func (gs *genService) generateSystemPairs() {
	f := gs.g.NewGroup()
	data := gs.data

	for _, pair := range SortPairs(data.Pairs) {
		pname := templateutils.ToPascal(pair.Name)

		f.AddLineComment(`With%s will apply %s value to Options.

%s`, pname, pair.Name, pair.Description)
		fn := f.NewFunction("With" + pname)

		// Set to true as default.
		value := "true"
		// bool type pairs don't need input.
		if pair.Type.Name != "bool" {
			fn.AddParameter("v", pair.Type.FullName(data.Name))
			value = "v"
		}
		fn.AddResult("", "types.Pair")
		fn.AddBody(gg.Return(
			gg.Value("types.Pair").
				AddField("Key", gg.Lit(pair.Name)).
				AddField("Value", value)))
	}
}

func (gs *genService) generateNamespace(nsName string) {
	f := gs.g.NewGroup()
	data := gs.data

	_ = data.Namespaces[nsName]
	nsNameP := templateutils.ToPascal(nsName)

	// Generate interface assert.
	inters := f.NewVar()
	inters.AddTypedField(
		"_", gg.S("types.%s", nsNameP+"r"), gg.S("&%s{}", nsNameP))

	// Generate feature struct.
	featureStructName := nsNameP + "Feature"
	f.AddLineComment("Deprecated: Use types.%s instead.", featureStructName)
	f.AddTypeAlias(featureStructName, "types."+featureStructName)

	// Generate default pairs.
	defaultStructName := fmt.Sprintf("Default%sPairs", nsNameP)
	f.AddLineComment("Deprecated: Use types.%s instead.", defaultStructName)
	f.AddTypeAlias(defaultStructName, "types."+defaultStructName)

	// TODO: generate Features() function.

	for _, op := range SortOperations(GetOperations(nsName)) {
		// Generate pair struct.

		// Generate public functions.
		gs.generateFunction(nsName, op)
	}
}
func (gs *genService) generateFactory() {
	panic("implement me")
}
func (gs *genService) generateFeatures(nsName string) {
	panic("implement me")
}
func (gs *genService) generateFunction(nsName string, op Operation) {
	nsNameP := templateutils.ToPascal(nsName)
	fnNameP := templateutils.ToPascal(op.Name)

	data := gs.data
	f := gs.g.NewGroup()

	// Generate a local function.
	if op.Local {
		xfn := f.NewFunction(fnNameP).WithReceiver("s", "*"+nsNameP)
		for _, field := range op.Params {
			xfn.AddParameter(field.Name, field.Type.FullName(data.Name))
		}
		for _, field := range op.Results {
			xfn.AddResult(field.Name, field.Type.FullName(data.Name))
		}
		xfn.AddBody(
			gg.S("pairs = append(pairs, s.defaultPairs.%s...)", fnNameP),
			gg.S("var opt pair%s%s", nsNameP, fnNameP),
			gg.Line(),
			gg.LineComment("Ignore error while handling local functions."),
			gg.S("opt, _ = s.parsePair%s%s(pairs)", nsNameP, fnNameP),
			gg.Return(
				gg.Embed(func() gg.Node {
					ic := gg.Call(templateutils.ToCamel(op.Name)).
						WithOwner("s")
					for _, v := range op.Params {
						// We don't need to call pair again.
						if v.Name == "pairs" {
							continue
						}
						ic.AddParameter(v.Name)
					}
					ic.AddParameter("opt")
					return ic
				})))
		return
	}

	xfn := f.NewFunction(fnNameP).
		WithReceiver("s", "*"+nsNameP)
	for _, field := range op.Params {
		xfn.AddParameter(field.Name, field.Type.FullName(data.Name))
	}
	for _, field := range op.Results {
		xfn.AddResult(field.Name, field.Type.FullName(data.Name))
	}
	xfn.AddBody(
		"ctx := context.Background()",
		gg.Return(
			gg.Embed(func() gg.Node {
				ic := gg.Call(fnNameP + "WithContext").
					WithOwner("s")
				ic.AddParameter("ctx")
				for _, v := range op.Params {
					if v.Name == "pairs" {
						ic.AddParameter("pairs...")
						continue
					}
					ic.AddParameter(v.Name)
				}
				return ic
			})))

	xfn = f.NewFunction(fnNameP+"WithContext").
		WithReceiver("s", "*"+nsNameP)
	xfn.AddParameter("ctx", "context.Context")
	for _, field := range op.Params {
		xfn.AddParameter(field.Name, field.Type.FullName(data.Name))
	}
	for _, field := range op.Results {
		xfn.AddResult(field.Name, field.Type.FullName(data.Name))
	}
	xfn.AddBody(
		gg.Defer(gg.Embed(func() gg.Node {
			caller := gg.Call("formatError").WithOwner("s")
			caller.AddParameter(gg.Lit(op.Name)).AddParameter("err")
			isEmpty := true
			for _, v := range op.Params {
				// formatError only accept string as input.
				if v.Type.Name != "string" {
					continue
				}
				caller.AddParameter(v.Name)
				isEmpty = false
			}
			if isEmpty && nsName == NamespaceService {
				caller.AddParameter("\"\"")
			}

			fn := gg.Function("").
				AddBody(gg.S("err = "), caller).WithCall()
			return fn
		})),
		gg.S("pairs = append(pairs, s.defaultPairs.%s...)", fnNameP),
		gg.S("var opt pair%s%s", nsNameP, fnNameP),
		gg.Line(),
		gg.S("opt, err = s.parsePair%s%s(pairs)", nsNameP, fnNameP),
		gg.If(gg.S("err != nil")).AddBody(gg.Return()),
		gg.Return(
			gg.Embed(func() gg.Node {
				ic := gg.Call(templateutils.ToCamel(op.Name)).
					WithOwner("s")
				ic.AddParameter("ctx")
				for _, v := range op.Params {
					// We don't need to call pair again.
					if v.Name == "pairs" {
						continue
					}
					if v.Name == "path" || v.Name == "src" || v.Name == "dst" || v.Name == "target" {
						ic.AddParameter(gg.S(`strings.ReplaceAll(%s, "\\", "/")`, v.Name))
						continue
					}
					ic.AddParameter(v.Name)
				}
				ic.AddParameter("opt")
				return ic
			})))
}
